import{_ as l,o as c,c as h,a as t,b as e,d as n,w as u,e as p,f as a,r as o}from"./app.87197fef.js";const i="/assets/tree-sitter-simple-indentation.6a2dba5c.webm",r="/assets/tree-sitter-simple-indentation.7d0eae68.mp4",m="/assets/tree-sitter-tools-indentation-example.52c421af.png",v="/assets/tree-sitter-advanced-indentation-part-1.98936604.webm",b="/assets/tree-sitter-advanced-indentation-part-1.33a3a459.mp4",g="/assets/tree-sitter-advanced-indentation-part-2.e941a3ba.webm",f="/assets/tree-sitter-advanced-indentation-part-2.9c4500ba.mp4",w="/assets/tree-sitter-simple-fold-example.8070404a.png",y="/assets/tree-sitter-tools-css-block.47b94e88.png",k="/assets/tree-sitter-javascript-block-comment.812590a9.png",x="/assets/tree-sitter-block-comment-code-fold.b6a82fbf.webm",_="/assets/tree-sitter-block-comment-code-fold.28ab19f5.mp4",T="/assets/tree-sitter-simple-folding.5bf37994.webm",q="/assets/tree-sitter-simple-folding.ac70c9fb.mp4",I={},S=t("p",null,"Today we\u2019ll look at two other systems \u2014 indentation hinting and code folding \u2014 and I\u2019ll explain how queries can be used to support each one.",-1),j=a(`<h2 id="indentation" tabindex="-1"><a class="header-anchor" href="#indentation" aria-hidden="true">#</a> Indentation</h2><p>Our programmer predecessors might scoff at how much our editors coddle us, but I\u2019ll say it anyway: I hate it when my editor doesn\u2019t know when to indent. In particular, C-style languages like JavaScript have predictable and simple rules about indentation, so when an editor guesses wrong, it\u2019s like a burst of static in the middle of a song.</p><p>If I type</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">{</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>and press <kbd>Return</kbd>, all major code editors will indent the next line for me by one level. There\u2019s no reason for an editor to force me to press <kbd>Tab</kbd> myself \u2014 it\u2019s obvious from context.</p><p>And once I\u2019m done with the conditional and type <code>}</code> on its own line, my editor should recognize that this line isn\u2019t part of the indented block, and should decrease the indentation by one level automatically.</p><video style="max-width:100%;" autoplay controls muted loop><source src="`+i+'" type="video/webm"><source src="'+r+'" type="video/mp4"><p>Your browser doesn\u2019t support HTML video. <a href="@source/blog/assets/tree-sitter-simple-indentation.mp4">Download this video</a> instead.</p></video><p>How does Pulsar do this now? And how can we swap in our own system for doing it with Tree-sitter?</p><h3 id="how-textmate-grammars-do-it" tabindex="-1"><a class="header-anchor" href="#how-textmate-grammars-do-it" aria-hidden="true">#</a> How TextMate grammars do it</h3><p>Pulsar, like Atom before it, uses an indentation hinting system based on the system from TextMate grammars. It works a bit like this:</p><ul><li><strong>Use the previous line\u2019s content to decide whether a new line is indented.</strong> When a user presses <kbd>Return</kbd>, a TextMate grammar will test the line the cursor was just on against a regular expression called <code>increaseIndentPattern</code>. If there\u2019s a match, it concludes that the next line should start with an extra level of indentation.</li><li><strong>Use a line\u2019s own content to decide when it should be dedented.</strong> Since only certain kinds of content \u2014\xA0like <code>}</code> or <code>end</code> \u2014\xA0signify the end of a block, a TextMate grammar will test the current line against a regular expression called <code>decreaseIndentPattern</code> over and over as the user types. If that pattern ever matches, the current line will be dedented one level.</li></ul><p>For JavaScript, imagine that <code>increaseIndentPattern</code> can be described as \u201Can opening brace without a matching closing brace,\u201D and <code>decreaseIndentPattern</code> can be described as \u201Ca closing brace that is not preceded by an opening brace.\u201D Each pattern would probably need to match more than <em>just</em> those situations, but that\u2019s the most important pattern to recognize by far.</p><p>Let\u2019s look at that screencast again to see these rules in action:</p><video style="max-width:100%;" autoplay controls muted loop><source src="'+i+'" type="video/webm"><source src="'+r+'" type="video/mp4"><p>Your browser doesn\u2019t support HTML video. <a href="@source/blog/assets/tree-sitter-simple-indentation.mp4">Download this video</a> instead.</p></video><p>The first rule comes into play when we press <kbd>Return</kbd> at the end of line 2. A newline is inserted, and the cursor is correctly indented by one additional level.</p><p>The second rule reacts after we type a <code>}</code> on line 4: now the line\u2019s content matches <code>decreaseIndentPattern</code>, and the line is dedented automatically.</p><h3 id="how-legacy-tree-sitter-grammars-do-it" tabindex="-1"><a class="header-anchor" href="#how-legacy-tree-sitter-grammars-do-it" aria-hidden="true">#</a> How legacy Tree-sitter grammars do it</h3><p>The same way. No, seriously.</p><p>It was obviously meant to be temporary, but legacy Tree-sitter grammars rely on the same <code>increaseIndentPattern</code> and <code>decreaseIndentPattern</code> that TextMate grammars use. We should come up with a Tree-sitter\u2013based system instead.</p><p>TextMate\u2019s deep embrace of regular expressions is a double-edged sword: it makes simple things easy, but it makes complex things nearly impossible. Instead of testing lines against a single regular expression \u2014 which can quickly get unwieldy as it expands to handle all possible indentation hinting scenarios \u2014 we can use Tree-sitter\u2019s query system to identify code features that would affect indentation.</p>',20),P={href:"https://github.com/mauricioszabo",target:"_blank",rel:"noopener noreferrer"},H={href:"https://github.com/nvim-treesitter/nvim-treesitter/blob/v0.9.1/doc/nvim-treesitter.txt#L210",target:"_blank",rel:"noopener noreferrer"},M=a(`<h3 id="working-within-the-system" tabindex="-1"><a class="header-anchor" href="#working-within-the-system" aria-hidden="true">#</a> Working within the system</h3><p>We could\u2019ve just adopted Neovim\u2019s system wholesale. But I wanted a system that kept the same <em>decision points</em> as the TextMate system for conceptual simplicity. So we\u2019ve built a system that will abide by the contract described above\u2026</p><ol><li>To figure out whether to <em>indent</em> a line, look at the content of the line above it.</li><li>To figure out whether to <em>dedent</em> a line, look at the content of that line itself.</li></ol><p>\u2026except using its own logic:</p><ol><li>When a user presses <kbd>Return</kbd>, instead of checking the previous line against <code>increaseIndentPattern</code>, we\u2019ll instead run a query capture against the previous line and look at the results to figure out whether to indent the new line.</li><li>When a user types on the current line, instead of checking it against <code>decreaseIndentPattern</code>, we\u2019ll run a query capture against that line with each keystroke and look for results that imply we should dedent that line relative to the line above.</li></ol><p>Remember that Tree-sitter produces <em>concrete</em> syntax trees; every node represents an actual buffer range. The things that are typically stripped from <em>abstract</em> syntax trees, like punctuation, are still present in a Tree-sitter tree, and can be queried. That\u2019s good news for us: looking at punctuation is a great way to predict how lines should be indented.</p><p>So let\u2019s start here. Imagine this content exists in a file called <code>indents.scm</code>:</p><div class="language-scm ext-scm line-numbers-mode"><pre class="language-scm"><code>&quot;{&quot; @indent
&quot;}&quot; @dedent
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>This is maybe the simplest possible system for describing indentation in a C-style language. For some languages, like CSS, this gets us 99% of the way to a perfect indentation system. But how does it work?</p>`,9),A={href:"https://web.pulsar-edit.dev/packages/tree-sitter-tools",target:"_blank",rel:"noopener noreferrer"},L=t("code",null,"tree-sitter-tools",-1),C={href:"https://pulsar-edit.dev/blog/20230925-savetheclocktower-modern-tree-sitter-part-1.html#can-i-use-this-new-implementation-now",target:"_blank",rel:"noopener noreferrer"},B=t("li",null,"Open a new document, change the grammar to CSS, and type some sample CSS.",-1),R=t("li",null,[e("Run the "),t("strong",null,"Tree Sitter Tools: Open Inspector For Editor"),e(" command.")],-1),W=t("li",null,[e("Toggle the \u201CAnonymous nodes\u201D option to "),t("strong",null,"Show"),e(".")],-1),E=t("li",null,[e("Paste that code block into the appropriate text box and click on "),t("kbd",null,"Run Query"),e(".")],-1),N=a('<p><img src="'+m+`" alt="tree-sitter-tools indentation example"></p><p>You can see the query matches illustrated in the text editor in real time, and you can match up the colors to the <code>@indent</code> and <code>@dedent</code> captures. You can even type new content (as in the examples below) and see the captures update in real time!</p><p>Let\u2019s say the user is writing a CSS file, and the cursor is represented by the <code>|</code> character:</p><div class="language-css ext-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">body</span> <span class="token punctuation">{</span>|
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>If the user were to press <kbd>Return</kbd>, we\u2019d run a query capture on a specific range of the buffer: from the start of row 1 to wherever the cursor was. The opening brace on row 1 would produce a single capture called <code>@indent</code>. Based on that information, we\u2019d know that row 2 should be indented by one level.</p><p>But what if the file looked like this instead?</p><div class="language-css ext-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">body</span> <span class="token punctuation">{</span> <span class="token property">font-family</span><span class="token punctuation">:</span> <span class="token string">&#39;Helvetica&#39;</span><span class="token punctuation">,</span> sans-serif<span class="token punctuation">;</span> <span class="token punctuation">}</span>|
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>If the user were to press <kbd>Return</kbd>, we\u2019d run the same query capture, and it would match twice: one <code>@indent</code> capture and one <code>@dedent</code> capture. Those captures would <em>cancel each other out</em>. We\u2019d know that the opening brace we saw had already been balanced by a later closing brace, and we\u2019d know that row 2 <em>should not</em> increase its indentation level.</p><p>Now let\u2019s look at one more example:</p><div class="language-css ext-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">body</span> <span class="token punctuation">{</span>
  <span class="token property">font-family</span><span class="token punctuation">:</span> <span class="token string">&#39;Helvetica&#39;</span><span class="token punctuation">,</span> sans-serif<span class="token punctuation">;</span>
  |
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>After typing one property-value pair and pressing <kbd>Return</kbd>, we\u2019re on row 3. Should this line be dedented? It depends on what we\u2019re about to type! If we\u2019re about to type <code>}</code>, then the answer is <em>yes</em> \u2014 but if we\u2019re typing anything else, like another property-value pair, then the answer is <em>no</em>. That\u2019s why Pulsar won\u2019t decide whether to dedent <em>until we start typing</em>. If we were to type <code>}</code>, our Tree-sitter grammar would run a query capture on the current line, spot the <code>@dedent</code> match, and respond by dedenting the current line one level from the line above.</p><p>For more complex C-style languages like JavaScript, here\u2019s a better starting point for <code>indents.scm</code>:</p><div class="language-scm ext-scm line-numbers-mode"><pre class="language-scm"><code>; Any of these characters should trigger indent\u2026
[ &quot;{&quot; &quot;(&quot; &quot;[&quot; ] @indent

; \u2026and any of these should trigger dedent.
[ &quot;}&quot; &quot;)&quot; &quot;]&quot; ] @dedent
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>There are major simplicity benefits to targeting these anonymous nodes instead of more abstract nodes. Most folks\u2019 indentation styles tend to align with delimiter usage, so the more tightly we can bind to the delimiters themselves, the more accurate the hinting will be. And anonymous nodes are safer to rely upon as the user types and the syntax tree is in flux. Sometimes we have to \u201Cfilter out\u201D false positives \u2014 for instance, curly braces in JavaScript that signify template string interpolations instead of statement blocks \u2014 but that\u2019s a small price to pay.</p><p>I\u2019m hiding some of the complexity from you, but less than you\u2019d think. This is a much friendlier way to describe indentation hinting than making a grammar author maintain an ever-more-complex set of regular expressions. It allows the author to describe each kind of indentation hint as its own rule.</p><h3 id="getting-creative" tabindex="-1"><a class="header-anchor" href="#getting-creative" aria-hidden="true">#</a> Getting creative</h3><p>And it allows us to do some more complex things that weren\u2019t possible before.</p><p>TextMate\u2019s system will let us indent or dedent <em>one level at a time</em>. But consider a <code>switch</code> statement:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">switch</span> <span class="token punctuation">(</span>foo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">case</span> <span class="token string">&quot;bar&quot;</span><span class="token operator">:</span>
		<span class="token comment">// one thing</span>
		<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token keyword">case</span> <span class="token string">&quot;baz&quot;</span><span class="token operator">:</span>
		<span class="token comment">// another thing</span>
		<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token keyword">default</span><span class="token operator">:</span>
	<span class="token comment">// a third thing</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Between the second-to-last line and the last line, there\u2019s a <em>two-level</em> change in indentation. How can we express that?</p><p>Here\u2019s where our syntax tree comes in handy. Instead of describing our desired indentation level relative to the previous line, we can describe it relative to a line of our choosing:</p><div class="language-scm ext-scm line-numbers-mode"><pre class="language-scm"><code>; The closing brace of a switch statement&#39;s body should match the indentation
; of the line where the switch statement starts.
(switch_statement
  body: (switch_body &quot;}&quot; @match)
  (#set! indent.matchIndentOf parent.startPosition))

; &#39;case&#39; and &#39;default&#39; need to be indented one level more than their containing
; \`switch\`.
([&quot;case&quot; &quot;default&quot;] @match
  (#set! indent.matchIndentOf parent.parent.startPosition)
  (#set! indent.offsetIndent 1))

[&quot;case&quot; &quot;default&quot;] @indent
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,22),O=t("code",null,"@match",-1),z=t("em",null,"node position descriptor",-1),Y={href:"https://pulsar-edit.dev/blog/20231013-savetheclocktower-modern-tree-sitter-part-3.html#adjusting-by-node-position-descriptor",target:"_blank",rel:"noopener noreferrer"},D=a(`<p>In the first rule, we\u2019re matching the closing <code>}</code> of a <code>switch</code> statement. We\u2019re using a <code>#set!</code> predicate to describe the starting position of its <code>switch_body</code> parent. The <code>switch_body</code> starts on row 1, so <code>@match</code> understands this to mean \u201Cadjust the current line to match the indentation of row 1.\u201D This will happen automatically when the user types the closing brace.</p><p>In the second rule, we\u2019re using similar logic. If we were typing the above <code>switch</code> statement, we\u2019d find ourselves over-indented as we started typing on line 5. We\u2019d want our editor to dedent that line once it saw that we were typing a new branch of the <code>switch</code> statement. So we can write another <code>@match</code> rule \u2014 still targeting the indentation level of the starting row of <code>switch_body</code> \u2014\xA0but with an extra rule to <em>offset</em> the indent by one level. In other words, we want to be indented <em>one level more</em> than the indent level of row 1.</p><p>The third rule is simpler: it\u2019s how we ensure that the editor indents by one level after <code>case</code> and <code>default</code> statements.</p><p>You might\u2019ve had your hackles raised by this example. After all, there\u2019s another school of thought on how to indent <code>switch</code> statements:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">switch</span> <span class="token punctuation">(</span>foo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">case</span> <span class="token string">&quot;bar&quot;</span><span class="token operator">:</span>
	<span class="token comment">// one thing</span>
	<span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token keyword">case</span> <span class="token string">&quot;baz&quot;</span><span class="token operator">:</span>
	<span class="token comment">// another thing</span>
	<span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token keyword">default</span><span class="token operator">:</span>
	<span class="token comment">// a third thing</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This faction thinks that <code>case</code> and <code>default</code> statements should be indented to the same level as the original <code>switch</code> statement. How can we please both camps?</p><p>One way might be to write two different versions of our second rule, and decide which one to use based on configuration:</p><div class="language-scm ext-scm line-numbers-mode"><pre class="language-scm"><code>
; Some say &#39;case&#39; and &#39;default&#39; need to be indented one level more than their
; containing \`switch\`.
([&quot;case&quot; &quot;default&quot;] @match
  (#is? test.config &quot;language-javascript.doubleIndentSwitchStatements&quot;)
  (#set! indent.matchIndentOf parent.parent.startPosition)
  (#set! indent.offsetIndent 1))

; Others say &#39;case&#39; and &#39;default&#39; should match their containing \`switch\`.
([&quot;case&quot; &quot;default&quot;] @match
  (#is-not? test.config &quot;language-javascript.doubleIndentSwitchStatements&quot;)
  (#set! indent.matchIndentOf parent.parent.startPosition))
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Here we\u2019re using a <code>test.config</code> scope test. I told you about scope tests last time, but I haven\u2019t yet mentioned that they don\u2019t just apply to syntax highlighting queries; they apply to indentation queries, too!</p><p>The <code>test.config</code> scope test gives us a way to approve or reject a capture based on the user\u2019s chosen configuration. If they\u2019ve enabled the <code>doubleIndentSwitchStatements</code> config option, we can indent their code one way; if they\u2019ve disabled it, we can indent their code another way.</p><p>This particular example <strong>isn\u2019t yet implemented</strong>, but it could be. This would be another advantage that the new Tree-sitter system has over TextMate-style indentation hinting: more room for configurability.</p><p>Here\u2019s another edge case of indentation: a braceless <code>if</code> statement.</p><video style="max-width:100%;" autoplay controls muted loop><source src="`+v+'" type="video/webm"><source src="'+b+`" type="video/mp4"><p>Your browser doesn\u2019t support HTML video. <a href="@source/blog/assets/tree-sitter-advanced-indentation-part-1.mp4">Download this video</a> instead.</p></video><p>How did we pull this off? Haven\u2019t we been targeting nodes like <code>{</code> and <code>}</code>?</p><p>Yes, but we can also write rules to handle one-line conditionals like these:</p><div class="language-scm ext-scm line-numbers-mode"><pre class="language-scm"><code>(if_statement
  condition: (parenthesized_expression &quot;)&quot; @indent
  (#is? test.lastTextOnRow true)))
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Here we\u2019ve written a query that captures the closing <code>)</code> of a braceless <code>if</code> statement and uses <em>that</em> as the indentation hint. We\u2019re also using a scope test to ensure the capture is ignored when it isn\u2019t the last text on the row; that\u2019s how we can avoid a false positive in this scenario:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>notificationsAreDisabled<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>A braceless <code>if</code> or <code>else</code> applies only to the next statement. The real feat is knowing to dedent <em>immediately</em> after that statement:</p><div class="language-scm ext-scm line-numbers-mode"><pre class="language-scm"><code>(if_statement
  condition: (_) @indent
  consequence: [
    (expression_statement)
    (return_statement)
    (continue_statement)
    (break_statement)
    (throw_statement)
    (debugger_statement)
  ] @dedent.next)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>An <code>if</code> clause <em>with</em> braces will have a node named <code>statement_block</code> in its <code>consequence</code> slot. An <code>if</code> clause <em>without</em> braces will have its <code>consequence</code> slot filled with one of these six kinds of nodes instead.</p><p>The <code>@dedent.next</code> capture is only rarely needed, but this is a textbook case: it signals when we should dedent the next line <em>without</em> waiting to see the content of the line. Because we know that the next line should <em>always</em> be dedented in this scenario.</p><p>How well does this work? Amazingly well:</p><video style="max-width:100%;" autoplay controls muted loop><source src="`+g+'" type="video/webm"><source src="'+f+'" type="video/mp4"><p>Your browser doesn\u2019t support HTML video. <a href="@source/blog/assets/tree-sitter-advanced-indentation-part-2.mp4">Download this video</a> instead.</p></video><p>Tree-sitter isn\u2019t confused by the line comment! It won\u2019t dedent until after the user types an actual statement.</p><p>Does this matter a great deal? Is it worth creating detailed rules to cover a breadth of unusual indentation scenarios? Probably not. But this is just one of a handful of low-hanging fruit that the new system has made possible. Even the slightly verbose query above is much easier to write (and for other people to reason about) than an inscrutable regular expression.</p><h2 id="code-folding" tabindex="-1"><a class="header-anchor" href="#code-folding" aria-hidden="true">#</a> Code folding</h2><p>I\u2019m not someone who uses code folding very much, but I want it to be there when I need it. Collapsing entire code branches helps me see the big picture more easily.</p><h3 id="how-textmate-grammars-do-it-1" tabindex="-1"><a class="header-anchor" href="#how-textmate-grammars-do-it-1" aria-hidden="true">#</a> How TextMate grammars do it</h3><p>Much like indentation, code folding markers in TextMate grammars are determined with regular expressions. Any line that matches <code>foldingStartMarker</code> is treated as the start of a fold, and any line that matches <code>foldingEndMarker</code> is treated as the end of a fold. This offers similar tradeoffs to the indentation patterns described above: simple for simple cases, but nearly impossible for complex cases.</p><h3 id="how-legacy-tree-sitter-grammars-do-it-1" tabindex="-1"><a class="header-anchor" href="#how-legacy-tree-sitter-grammars-do-it-1" aria-hidden="true">#</a> How legacy Tree-sitter grammars do it</h3>',31),F={href:"https://github.com/pulsar-edit/pulsar/blob/v1.110.0/packages/language-javascript/grammars/tree-sitter-javascript.cson#L18-L53",target:"_blank",rel:"noopener noreferrer"},J=t("h3",{id:"using-queries-to-define-fold-ranges",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#using-queries-to-define-fold-ranges","aria-hidden":"true"},"#"),e(" Using queries to define fold ranges")],-1),V=t("code",null,"nvim-treesitter",-1),U={href:"https://github.com/mauricioszabo",target:"_blank",rel:"noopener noreferrer"},G=a(`<div class="language-scm ext-scm line-numbers-mode"><pre class="language-scm"><code>(block) @fold
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>That\u2019s the <em>entirety</em> of the contents of the <code>folds.scm</code> file inside the <code>language-css</code> package. This works because a starting position and an ending position are all you need to describe a fold, and that\u2019s what Tree-sitter gives us. Every node in a tree reports its buffer positions, so every node can be the target of a fold.</p><p><img src="`+w+'" alt="tree sitter simple fold example"></p><p>Let\u2019s go a bit deeper and figure out what this does.</p><p>When it opens a file, Pulsar needs to figure out where possible fold ranges are so that it can show a small chevron in the gutter on each line where a fold can start. So it\u2019ll run a query capture against each line, testing it to see if any <code>@fold</code> captures result.</p><p>Any results will have their buffer ranges inspected. If the range starts and ends on the same line, the candidate fold is ignored. (This saves grammar authors from having to manually exclude things like one-line conditionals.) But if the range starts on one line and ends on another, the fold is valid, and Pulsar knows to place a chevron in the gutter where the fold would start.</p><p>The <strong>beginning</strong> of a code fold is the very last column on its starting line. In most cases, the range in question will have delimiters on each end \u2014 the backticks of a template string, the curly braces of an <code>if</code> or <code>else</code> condition, et cetera. That\u2019s why, by default, the <strong>end</strong> of a code fold is the <em>starting</em> position of its very last node child. This works as intended in the vast majority of cases, as in our CSS example above:</p><p><img src="'+y+'" alt="tree-sitter-tools node hierarchy illustration"></p><p>But because this isn\u2019t always true \u2014 especially for languages like Python that don\u2019t use delimiters for blocks \u2014 we provide ways to tweak a fold\u2019s ending position.</p><p>For instance, let\u2019s look at a JavaScript block comment:</p><p><img src="'+k+`" alt="JavaScript block comment"></p><p>Since comment nodes don\u2019t have children, we should set a custom ending position for the fold with <code>fold.endAt</code> so that it doesn\u2019t try to look up a child node that doesn\u2019t exist. Then we can use <code>fold.offsetEnd</code> to move the ending point of the fold two columns to the left so that the fold ends before the comment\u2019s ending delimiter:</p><div class="language-scm ext-scm line-numbers-mode"><pre class="language-scm"><code>((comment) @fold
  (#set! fold.endAt endPosition)
  (#set! fold.offsetEnd -2))
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Now we can fold up the block comment the way we want:</p><video style="max-width:100%;" autoplay controls muted loop><source src="`+x+'" type="video/webm"><source src="'+_+`" type="video/mp4"><p>Your browser doesn\u2019t support HTML video. <a href="@source/blog/assets/tree-sitter-block-comment-code-fold.mp4">Download this video</a> instead.</p></video><p>Folding in JavaScript is still pretty simple, but not as simple as CSS. We\u2019ve got to account for some edge cases. For example, when an <code>if</code> statement is followed by an <code>else</code>, we should adjust the fold so that it ends on the line <em>before</em> the <code>else</code>, so that each fold can be toggled independently without interfering with one another:</p><div class="language-scm ext-scm line-numbers-mode"><pre class="language-scm"><code>; Target \`if\` consequence blocks that are followed by \`else\`s.
((if_statement
  consequence: (statement_block) @fold
  alternative: (else_clause)
  (#set! fold.adjustToEndOfPreviousRow true)
))

; Other \`if\` consequence blocks will get caught here.
(statement_block) @fold
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>You can see how this works in the screencast below \u2014 the <code>else</code> block\u2019s closing delimiter folds up to be on the same line as the starting delimiter, but the <code>if</code> block\u2019s fold stops before the newline.</p><video style="max-width:100%;" autoplay controls muted loop><source src="`+T+'" type="video/webm"><source src="'+q+'" type="video/mp4"><p>Your browser doesn\u2019t support HTML video. <a href="@source/blog/assets/tree-sitter-simple-folding.mp4">Download this video</a> instead.</p></video><p>\u201CEnd the fold at the end of the previous line\u201D is a common enough case to have its own shorthand predicate. We\u2019ve put this special-case query above the simpler one because Pulsar will use the first capture that matches for a given line.</p><h2 id="why-is-this-so-complicated" tabindex="-1"><a class="header-anchor" href="#why-is-this-so-complicated" aria-hidden="true">#</a> Why is this so complicated?</h2><p>I\u2019ll say it again: this tour through the machinery of Pulsar is aimed at Tree-sitter aficionados and at those who might want to write their own language packages for Pulsar. If that doesn\u2019t describe you, don\u2019t let yourself get overwhelmed by this information dump \u2014 just make note of the new features that this system makes possible.</p><p>There are pieces of the indentation and folding systems that I didn\u2019t even try to explain in this post. But all this complexity has a purpose, and users reap the benefits in small increments \u2014 for instance, every time they <em>don\u2019t</em> have to go back and reformat code they paste into an editor.</p><p>These systems only work with the assistance of language grammars, so we owe it to the authors of those grammars to hide as much of that complexity as we can. If we can make these systems seem simple on the surface, they\u2019ll work better, and users will be happier.</p><h2 id="next-time" tabindex="-1"><a class="header-anchor" href="#next-time" aria-hidden="true">#</a> Next time</h2><p>Cue up your DVD of <cite>Inception</cite>! Next time we\u2019re delving into language injections \u2014 the feature that lets you write CSS inside of HTML inside of JavaScript inside of HTML inside of PHP.</p>',26);function Q(K,X){const d=o("RouterLink"),s=o("ExternalLinkIcon");return c(),h("div",null,[t("p",null,[e("Last time we looked at Tree-sitter\u2019s query system and showed how it can be used "),n(d,{to:"/blog/20231013-savetheclocktower-modern-tree-sitter-part-3.html"},{default:u(()=>[e("to make a syntax highlighting engine in Pulsar")]),_:1}),e(". But syntax highlighting is simply the most visible of the various tasks that a language package performs.")]),S,p(" more "),j,t("p",null,[t("a",P,[e("@mauricioszabo"),n(s)]),e(" had noticed "),t("a",H,[e("Neovim\u2019s prior art here"),n(s)]),e(", and had started to implement a similar system, so it was easy to pick up where he left off.")]),M,t("p",null,[e("If you\u2019re following along with "),t("a",A,[L,n(s)]),e(", you can visualize it:")]),t("ol",null,[t("li",null,[e("First, "),t("a",C,[e("make sure you\u2019ve enabled modern Tree-sitter"),n(s)]),e(".")]),B,R,W,E]),N,t("p",null,[e("Here we\u2019re using a new capture called "),O,e(". It can do exactly what we just described by using a "),z,e(" (an idea we introduced "),t("a",Y,[e("in the last installment"),n(s)]),e(") to refer to an earlier line.")]),D,t("p",null,[e("Legacy Tree-sitter grammars introduced a system for defining folds "),t("a",F,[e("within the grammar definition file itself"),n(s)]),e(" \u2014\xA0one that hooks into named nodes from the tree. It\u2019s a good start, but we can make something more expressive and flexible with queries.")]),J,t("p",null,[e("Again, credit goes to the "),V,e(" developers and to "),t("a",U,[e("@mauricioszabo"),n(s)]),e(" for envisioning how Tree-sitter queries can describe folds more simply. Here\u2019s how simple it can be in a language like CSS:")]),G])}const $=l(I,[["render",Q],["__file","20231031-savetheclocktower-modern-tree-sitter-part-4.html.vue"]]);export{$ as default};
