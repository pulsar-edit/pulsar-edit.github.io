import{_ as o,o as i,c as p,e as c,a,b as n,d as s,f as e,r as l}from"./app.87197fef.js";const r="/assets/tree-sitter-tools-style-element.6c7c3556.png",u="/assets/tree-sitter-injection-illustration.c0de6ada.png",d="/assets/tree-sitter-tools-tree-list.7475c4eb.png",h="/assets/tree-sitter-select-larger-syntax-node.522d277a.webm",k="/assets/tree-sitter-select-larger-syntax-node.07d04699.mp4",g="/assets/tree-sitter-tools-template-string.34be245b.png",m="/assets/tree-sitter-html-parser-injection.b2a40e1c.png",v="/assets/tree-sitter-todo-url-injection.231723ac.png",f={},b=a("p",null,[n("One annoying thing that software developers do is insist on writing in "),a("em",null,"more than one language at once"),n(". Web developers are espeically obnoxious about this \u2014 routinely, for instance, putting CSS inside their HTML, or HTML inside their JavaScript, or CSS inside their HTML inside their JavaScript.")],-1),y=a("p",null,[n("Code editors like Pulsar need to roll with this, so today we\u2019ll talk about how the modern Tree-sitter system handles what we call "),a("em",null,"injections"),n(".")],-1),w=e(`<p>The TextMate grammar system understands injections. In any context, a TextMate grammar can include a subset of its own rules\u2026 or an entirely separate grammar.</p><p>But Tree-sitter needs something a bit more elaborate. If I\u2019ve got CSS inside a <code>style</code> tag in my HTML file, now I\u2019ve got <em>two different parsers</em>, each responsible for a different range of code. If I make some changes inside that <code>style</code> block, both parsers need to react to it.</p><p>Injections cover a wide range of use cases \u2014\xA0from the examples above to fenced code blocks in Markdown files to special-purpose injections that recognize things like URLs. Injections allow us to do some powerful and useful things that would be hard to do otherwise \u2014 including some things that TextMate injections can\u2019t do at all.</p><h2 id="a-mental-model-for-injections" tabindex="-1"><a class="header-anchor" href="#a-mental-model-for-injections" aria-hidden="true">#</a> A mental model for injections</h2><p>Let\u2019s pretend we have a simple HTML file that looks like this:</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>en<span class="token punctuation">&quot;</span></span> <span class="token attr-name">dir</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>ltr<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>utf-8<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Sample<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>

		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
			<span class="token selector">body</span> <span class="token punctuation">{</span>
				<span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>

		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text/javascript<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
			window<span class="token punctuation">.</span>dataLayer <span class="token operator">=</span> window<span class="token punctuation">.</span>dataLayer <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">function</span> <span class="token function">gtag</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				dataLayer<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token function">gtag</span><span class="token punctuation">(</span><span class="token string">&quot;js&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">gtag</span><span class="token punctuation">(</span><span class="token string">&quot;config&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;G-ABCDEFGHIJ&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>We haven\u2019t gotten very close to the machinery so far in this series, but I\u2019ve been content to have you model this as a single document with a single Tree-sitter HTML parser responsible for all syntax highlighting. That works fine until we get to the contents of the <code>style</code> and <code>script</code> elements.</p><p>To the Tree-sitter HTML parser, a <code>style</code> element looks like this:</p><p><img src="`+r+`" alt="visualization of a style element in tree-sitter"></p><p>You can see that it performs the usual parsing on the start and end tags, but punts on parsing the CSS itself \u2014 instead marking it as <code>raw_text</code>. This is what it should do! It\u2019s not a CSS parser, after all. It treats the inline <code>script</code> element similarly, marking its contents as <code>raw_text</code> because it doesn\u2019t understand JavaScript.</p><p>To apply syntax highlighting to these areas, we need to bring in parsers that understand these languages.</p><p>So our mental model needs to evolve. Instead of one buffer with one parser, we have one buffer with three parsers. We need a name for \u201Ca region of the buffer that uses a specific grammar to be understood,\u201D so let\u2019s call it a <em>language layer</em>, because that\u2019s what Pulsar calls it under the hood.</p><h3 id="language-layers" tabindex="-1"><a class="header-anchor" href="#language-layers" aria-hidden="true">#</a> Language layers</h3><p>Imagine a simpler HTML file that doesn\u2019t have any inline <code>style</code> or <code>script</code> tags:</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>en<span class="token punctuation">&quot;</span></span> <span class="token attr-name">dir</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>ltr<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>utf-8<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Sample<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Here we\u2019re looking at a buffer with a single language layer at the root. When I type a new keystroke in this buffer, only one Tree-sitter parser has to do any re-parsing work, and only one layer needs to be consulted when re-applying syntax highlighting.</p><p>Once I add a <code>style</code> block\u2026</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>en<span class="token punctuation">&quot;</span></span> <span class="token attr-name">dir</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>ltr<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>utf-8<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Sample<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>

		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
			<span class="token selector">body</span> <span class="token punctuation">{</span>
				<span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>\u2026I trigger the creation of a second language layer. This new layer is a <em>child</em> of the root HTML layer \u2014\xA0because the HTML layer is its reason for being, and the CSS layer might go away in the future if the HTML layer changes. The new language layer uses a Tree-sitter CSS parser.</p><p>When I add back the <code>script</code> block\u2026</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>en<span class="token punctuation">&quot;</span></span> <span class="token attr-name">dir</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>ltr<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>utf-8<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Sample<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>

		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
			<span class="token selector">body</span> <span class="token punctuation">{</span>
				<span class="token property">padding</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>

		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text/javascript<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
			window<span class="token punctuation">.</span>dataLayer <span class="token operator">=</span> window<span class="token punctuation">.</span>dataLayer <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">function</span> <span class="token function">gtag</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				dataLayer<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			<span class="token function">gtag</span><span class="token punctuation">(</span><span class="token string">&quot;js&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">gtag</span><span class="token punctuation">(</span><span class="token string">&quot;config&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;G-ABCDEFGHIJ&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>\u2026I trigger the creation of another language layer: a JavaScript layer that is also a child of the root HTML layer. Now there are <em>three</em> layers that might need to be consulted for syntax highlighting and other tasks.</p><p><img src="`+u+'" alt="tree-sitter injection illustration"></p><p>And it doesn\u2019t stop here! Certain constructs inside of the JavaScript, like regular expressions or tagged template literals, might carry their own injections, in which case new language layers would be created as children of the JavaScript layer. The result is a tree of language layers which cooperate to apply syntax highlighting to our buffer.</p><p>This might feel impossibly complex, but it isn\u2019t. It\u2019s just a different approach to what was already being done with TextMate grammars. In a minute I\u2019ll explain how Pulsar manages this complexity.</p><h2 id="how-tree-sitter-envisions-injections" tabindex="-1"><a class="header-anchor" href="#how-tree-sitter-envisions-injections" aria-hidden="true">#</a> How Tree-sitter envisions injections</h2>',26),j={href:"https://tree-sitter.github.io/tree-sitter/syntax-highlighting#language-injection",target:"_blank",rel:"noopener noreferrer"},T=a("code",null,"injections.scm",-1),_=a("code",null,"injections.scm",-1),x=e(`<div class="language-scm ext-scm line-numbers-mode"><pre class="language-scm"><code>((script_element
  (raw_text) @injection.content)
 (#set! injection.language &quot;javascript&quot;))

((style_element
  (raw_text) @injection.content)
 (#set! injection.language &quot;css&quot;))
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),q={href:"https://en.wikipedia.org/wiki/Here_document#Perl-influenced",target:"_blank",rel:"noopener noreferrer"},I=e(`<div class="language-ruby ext-rb line-numbers-mode"><pre class="language-ruby"><code>list_items<span class="token punctuation">.</span><span class="token keyword">each</span> <span class="token keyword">do</span> <span class="token operator">|</span>item<span class="token operator">|</span>
  puts <span class="token string-literal heredoc-string"><span class="token delimiter"><span class="token punctuation">&lt;&lt;~</span><span class="token symbol">HTML</span></span><span class="token string">
    &lt;li&gt;</span><span class="token interpolation"><span class="token delimiter punctuation">#{</span><span class="token content">item<span class="token punctuation">.</span>name</span><span class="token delimiter punctuation">}</span></span><span class="token string">&lt;/li&gt;
  </span><span class="token delimiter"><span class="token symbol">HTML</span></span></span>
<span class="token keyword">end</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This is a thorough system, and we\u2019ve already shown how query files can solve problems like syntax highlighting and injection hinting. So it can solve our language injection problem, right?</p><h2 id="how-pulsar-implements-injections" tabindex="-1"><a class="header-anchor" href="#how-pulsar-implements-injections" aria-hidden="true">#</a> How Pulsar implements injections</h2><p>The stuff I just described makes a lot of sense, and it\u2019s possible we\u2019ll do it someday. But here\u2019s how Pulsar does it now:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>atom<span class="token punctuation">.</span>grammars<span class="token punctuation">.</span><span class="token function">addInjectionPoint</span><span class="token punctuation">(</span><span class="token string">&quot;text.html.basic&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">&quot;script_element&quot;</span><span class="token punctuation">,</span>
	<span class="token function">language</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token string">&quot;javascript&quot;</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token function">content</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> node<span class="token punctuation">.</span><span class="token function">child</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

atom<span class="token punctuation">.</span>grammars<span class="token punctuation">.</span><span class="token function">addInjectionPoint</span><span class="token punctuation">(</span><span class="token string">&quot;text.html.basic&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">&quot;style_element&quot;</span><span class="token punctuation">,</span>
	<span class="token function">language</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token string">&quot;css&quot;</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token function">content</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> node<span class="token punctuation">.</span><span class="token function">child</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This code block is the equivalent of the above query file for HTML injections. It\u2019s got a similar amount of flexibility for selecting a target (e.g., \u201Cthe second child of a <code>style_element</code> node\u201D) and the ability to determine the language name either dynamically or statically. But we\u2019ve done everything else via queries; why do we do injections this way instead?</p><ol><li><p>The <code>addInjectionPoint</code> API was added by the legacy Tree-sitter implementation. For reasons of continuity, it makes a lot of sense to keep using this API rather than switch to something that\u2019s functionally the same.</p></li><li><p>In fact, there\u2019s one thing that the <code>addInjectionPoint</code> API does that a hypothetical <code>injections.scm</code> file can\u2019t: it can be used to add injections to Language X <em>even by someone who doesn\u2019t control the <code>language-x</code> bundle</em>. This makes it far more useful to Pulsar! It means that someone can write their own parser that injects itself into another language, whether in the form of a community package or a few lines in a user\u2019s <code>init.js</code>.</p></li></ol><p>To me, it doesn\u2019t make sense to deprecate the <code>addInjectionPoint</code> approach when it can do things that a query-based approach can\u2019t. Still, lots of Tree-sitter parsers include that query file, so I imagine that Pulsar will eventually support it <em>in addition to</em> the <code>addInjectionPoint</code> API.</p><h3 id="how-does-it-know-which-language-to-use" tabindex="-1"><a class="header-anchor" href="#how-does-it-know-which-language-to-use" aria-hidden="true">#</a> How does it know which language to use?</h3><p>You might\u2019ve noticed that both the Tree-sitter query file example and our <code>addInjectionPoint</code> example refer to the to-be-injected language rather casually \u2014 <code>javascript</code> and <code>css</code>. Internally, grammars tend to refer to one another via their root scope \u2014 as in the <code>text.html.basic</code> case above. So why not just use the root scope?</p><p>Two reasons:</p>`,11),S=e("<li>In our example, the HTML grammar shouldn\u2019t necessarily hard-code references to the injectable grammars it wants. It makes more abstract sense to describe the language it wants as <code>javascript</code> instead of <code>source.js</code> \u2014 because more than one grammar could theoretically identify as a JavaScript grammar, and because a grammar might want to respond to more than one name. (<code>js</code> and <code>javascript</code>, <code>c++</code> and <code>cpp</code>, and so forth.)</li>",1),L={href:"https://en.wikipedia.org/wiki/Heredoc",target:"_blank",rel:"noopener noreferrer"},M=a("code",null,"javascript",-1),P=a("code",null,"source.js",-1),H={href:"https://github.com/pulsar-edit/pulsar/blob/v1.110.0/packages/language-javascript/grammars/tree-sitter-2-javascript.cson#L6",target:"_blank",rel:"noopener noreferrer"},C=a("h2",{id:"architecture",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#architecture","aria-hidden":"true"},"#"),n(" Architecture")],-1),O=a("p",null,[n("No matter which approach we use for "),a("em",null,"describing"),n(" injections, the job of "),a("em",null,"processing"),n(" injections is roughly the same. All of Pulsar\u2019s Tree-sitter support is written with the understanding that there could be an arbitrary number of grammars that need to be consulted when an edit happens. So the job of parsing a document is divided up into some number of "),a("code",null,"LanguageLayer"),n(" classes arranged hierarchically.")],-1),A={href:"https://web.pulsar-edit.dev/packages/tree-sitter-tools",target:"_blank",rel:"noopener noreferrer"},R=a("strong",null,"Tree Sitter Tools: Open Inspector For Editor",-1),D=e('<p><img src="'+d+'" alt="a list of language layers in a buffer"></p><p>The first item in the list will always be the \u201Croot\u201D tree. Other items, if present, represent injections. And because injected languages can have their own injections, this list can grow to arbitrary length.</p><p>When the user edits the buffer, even with a single keystroke, we re-parse the document from the root down as follows:</p><ol><li>The root layer re-parses.</li><li>When that\u2019s done, Pulsar looks for possible injections by querying for nodes that have been specified in calls to <code>addInjectionPoint</code>.</li><li>If those nodes match the criteria of <code>addInjectionPoint</code> <em>(does the injection describe a language whose name we can match to a grammar? does the node specified by the <code>content</code> callback exist?)</em>, then we try to match them up to the layers that already exist. Layers that can\u2019t be matched to current injection nodes are disposed of, and nodes that can\u2019t be matched to existing layers get new layers created for them.</li><li>The process starts over for each layer at the next level of depth in the tree until all injections are current and all parsers have re-parsed.</li></ol><p>Any keystroke can create a brand new injection <em>or</em> invalidate one that used to exist. If I put the cursor inside of <code>&lt;style&gt;</code> and insert an <code>x</code>, changing it to <code>&lt;styxle&gt;</code>, then the CSS injection would no longer exist, and its corresponding <code>LanguageLayer</code> instance would need to be destroyed. If I then undo my change, the parse tree restores the <code>style_element</code> node, and a new language layer is created.</p><p>Does this feel overwhelming? That\u2019s fair. After all, I\u2019m writing this blog post in a buffer with <strong>32</strong> different language layers across the various code examples, and you\u2019d think that would add up to one hell of a performance penalty on each keystroke. But it doesn\u2019t.</p><p>Here are a few reasons why:</p><ol><li><p>We don\u2019t revisit every single language layer on every single keystroke because we can determine when a given buffer change <em>cannot possibly</em> affect a given injection. For instance, if I\u2019m editing a section of my HTML file <em>outside</em> of the <code>style</code> block, then Pulsar knows it doesn\u2019t have to re-parse the CSS inside of that <code>style</code> block yet. It knows that the layer\u2019s parse tree, though <em>technically</em> stale, is not invalid, and will defer re-parsing until an edit happens within its extent of the buffer. (This is true even if those edits cause the <code>style</code> block to shift its position in the document!) As a result, lots of buffer changes can short-circuit the exhaustive process I just described.</p></li><li><p>Syntax highlighting <em>in particular</em> is designed for performance, even in injection scenarios. After a buffer\u2019s initial highlighting pass, a given section of code will retain its highlighting indefinitely, even if its position in the buffer shifts as the result of other edits.</p><p>Syntax re-highlighting only happens when a buffer range is specifically invalidated. When an edit happens, Tree-sitter tells us how that edit affects the syntax tree, which in turn tells us which parts of the buffer need to be re-highlighted \u2014 and, just as importantly, which parts <em>don\u2019t</em> need to be re-highlighted.</p></li><li><p>Tree-sitter is faster than you think it is. The smaller the edit, the more the parser can reuse its old work, and the faster the re-parse happens.</p></li><li><p>Hardly anything in this process happens synchronously, so buffer operations will <em>feel</em> fast even in the rare case where Tree-sitter needs time to catch up.</p></li></ol><h3 id="challenges" tabindex="-1"><a class="header-anchor" href="#challenges" aria-hidden="true">#</a> Challenges</h3>',9),J={href:"https://pulsar-edit.dev/blog/20231013-savetheclocktower-modern-tree-sitter-part-3.html",target:"_blank",rel:"noopener noreferrer"},N={href:"https://pulsar-edit.dev/blog/20231031-savetheclocktower-modern-tree-sitter-part-4.html",target:"_blank",rel:"noopener noreferrer"},B=e('<p>Annoyingly, the answer is different for each system. For instance:</p><ul><li>To support code folding in an environment with multiple injected languages, we\u2019d want to ask <em>each layer</em> for its code folds, then combine the results.</li><li>If the user presses <kbd>Return</kbd> and we want to know whether to indent the next line, we should ask <em>one specific layer</em> \u2014 the one most qualified to answer that question at the given cursor position.</li></ul><p>So sometimes we need to <em>aggregate</em> across layers, but other times we need to <em>pick a winner</em>.</p><p>Picking a winner is the obvious approach for indentation when you think it through. If I hit <kbd>Return</kbd> when the cursor is in a <code>script</code> block, then I\u2019m writing JavaScript, and the JavaScript layer should be the one making indentation decisions. More generally, this means that if more than one layer is active at a given buffer position, we should pick the <em>deepest</em> layer and ask it to decide. (Sometimes this means the deepest layer that <em>fulfills a certain criterion</em> \u2014\xA0in this case, the deepest layer that actually defines an indentation query.)</p><p>But aggregating is the obvious approach for other scenarios. Tree-sitter grammars get to support Pulsar\u2019s <strong>Editor: Select Smaller Syntax Node</strong> and <strong>Editor: Select Larger Syntax Node</strong> commands (you don\u2019t know you need them in your life until you give them a try!) and those commands should work properly across injection boundaries. So when either command is invoked with the cursor at a given position, we should figure out which nodes contain that point <em>regardless of which parse tree owns them</em>. Then we can arrange those nodes from smallest to largest.</p><video style="max-width:100%;" autoplay controls muted loop><source src="'+h+'" type="video/webm"><source src="'+k+'" type="video/mp4"><p>Your browser doesn\u2019t support HTML video. <a href="@source/blog/assets/tree-sitter-select-larger-syntax-node.mp4">Download this video</a> instead.</p></video><p>You can see the results here. As I expand the selection by invoking <strong>Select Larger Syntax Node</strong> over and over, the selection starts with nodes in the CSS injection, jumps to nodes in the parent JavaScript injection, then jumps again to nodes in the root HTML injection.</p><h2 id="strange-injection-tricks" tabindex="-1"><a class="header-anchor" href="#strange-injection-tricks" aria-hidden="true">#</a> Strange injection tricks</h2><p>Mixing languages in a single buffer is messy, so injections need some unusual features in order to deal with that messiness. These features can be used in surprising and powerful ways.</p><h3 id="redaction-in-injections" tabindex="-1"><a class="header-anchor" href="#redaction-in-injections" aria-hidden="true">#</a> \u201CRedaction\u201D in injections</h3><p>One thing that makes Tree-sitter injections more powerful than their TextMate equivalents is their ability to ignore content that isn\u2019t relevant to their jobs. The injection engine \u201Credacts\u201D all content except what it wants a given layer to see.</p><h4 id="redacting-children" tabindex="-1"><a class="header-anchor" href="#redacting-children" aria-hidden="true">#</a> Redacting children</h4><p>Suppose you had an <code>html</code> tagged template literal:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> markup <span class="token operator">=</span> html<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> &lt;p&gt;Copyright 2020\u20132023 John Doe&lt;/p&gt; </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Since the tag hints at the language name, Pulsar will give you HTML syntax highlighting for free inside the literal. But that literal is still JavaScript, so what happens if we do this?</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> now <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">let</span> markup <span class="token operator">=</span> html<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> &lt;p&gt;Copyright 2020\u2013</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>now<span class="token punctuation">.</span><span class="token function">getFullYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> John Doe&lt;/p&gt; </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>That <code>${now.getFullYear()}</code> part isn\u2019t actually HTML. This example won\u2019t confuse an HTML parser, so it\u2019s not a big deal; but there does exist valid content inside of a template interpolation that <em>definitely would</em> flummox the injection:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> evil <span class="token operator">=</span> html<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string"> &lt;p&gt;this might not </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token string">&quot;&lt;/p&gt;&quot;</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> get parsed correctly&lt;/p&gt; </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Ideally, the HTML injection wouldn\u2019t see that interpolation at all. So what if we could hide it?</p><p>We can. In fact, we <em>do</em>! Here\u2019s what that template string looks like in <code>tree-sitter-tools</code>:</p><p><img src="'+g+'" alt="tree-sitter-tools visualization of a JavaScript template string"></p><p>Our injection is defined such that we specify the <code>template_string</code> node as the content. That means Pulsar will use the buffer range of that node, but will <em>subtract</em> the ranges of any of the node\u2019s children!</p><p>We can visualize this with the \u201CShow injection ranges\u201D option in <code>tree-sitter-tools</code>:</p><p><img src="'+m+`" alt="disjoint content ranges in a Tree-sitter injection"></p><p>You can see that the HTML injection layer has two disjoint content ranges on either side of the interpolation. The Tree-sitter HTML parser won\u2019t even know the interpolation is there.</p><p>This behavior makes sense as a default, but it can be opted out of with <code>includeChildren: true</code> in <code>addInjectionPoint</code> if it gets in your way.</p><h4 id="redacting-via-content-callback" tabindex="-1"><a class="header-anchor" href="#redacting-via-content-callback" aria-hidden="true">#</a> Redacting via <code>content</code> callback</h4><p>A grammar author has another tool to control what gets redacted: the <code>content</code> callback. It\u2019s not limited to returning a single node! It can return an array of nodes, each with its own range; there\u2019s no obligation for those ranges to be adjacent.</p><p>Our first HTML injection example earlier applied its own subtle redaction. We specified a <code>type</code> of <code>script_element</code>, but a <code>content</code> callback that returns that element\u2019s second child (the <code>raw_text</code> node). So the <code>type</code> property tells Pulsar which node to query for <em>(create an injection for each <code>script</code> element)</em> but <code>content</code> selects the node(s) that will be meaningful to the parser <em>(omit the <code>&lt;script&gt;</code> and <code>&lt;/script&gt;</code> because those aren\u2019t JavaScript)</em>.</p><p>This flexibility means that it\u2019s possible for <em>all</em> your injections of a certain type to share <em>one</em> language layer. Instead of creating one layer for each of <em>N</em> different buffer ranges, you could create one layer with <em>N</em> disjoint content ranges. The trade-off is that an injection that covers more of the buffer will need to be re-parsed more often in response to buffer changes, but that trade-off might make sense in certain scenarios.</p><h3 id="macros-in-rust-c-c" tabindex="-1"><a class="header-anchor" href="#macros-in-rust-c-c" aria-hidden="true">#</a> Macros in Rust/C/C++</h3><p>C, C++, and Rust allow you to define macros via a preprocessor. Macros are weird for a parser: they can\u2019t be parsed as though they\u2019re valid source code, because they might be fragments of code that aren\u2019t syntactically valid until <em>after</em> preprocessing.</p><p>Hence they\u2019re a situation where a language might want to inject itself <em>into itself</em>. Consider this code example:</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">circleArea</span><span class="token expression"><span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">3.1415</span><span class="token operator">*</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>The <code>#define</code> keyword and the <code>circleArea(r)</code> preprocessor function signature have to be well-formed, but everything that follows is an anything-goes nightmare for a syntax highlighter. The preprocessor won\u2019t try to parse it or make it make sense; it\u2019ll just make the appropriate substitution throughout the source file and enforce validity later.</p><p>For the same reason, the <code>tree-sitter-c</code> parser doesn\u2019t attempt to do any parsing of the preprocessor argument \u2014 the <code>(3.1415*(r)*(r))</code> in our above example. But that argument will <em>often</em> be valid C, so there\u2019s no reason why we shouldn\u2019t take a stab at it:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>atom<span class="token punctuation">.</span>grammars<span class="token punctuation">.</span><span class="token function">addInjectionPoint</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">source.c</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">&quot;preproc_function_def&quot;</span><span class="token punctuation">,</span>
	<span class="token function">language</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token string">&quot;c&quot;</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token function">content</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> node<span class="token punctuation">.</span>lastNamedChild<span class="token punctuation">;</span> <span class="token comment">// the \`preproc_arg\` node</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This is a low-stakes gambit for us. If the content of the macro <em>is</em> syntactically strange, the parser might get a bit flummoxed, and the resulting highlighting might look a bit weird. But that\u2019s OK! It won\u2019t affect the highlighting of anything <em>outside of</em> the macro content.</p><h3 id="injecting-highlighting-for-urls-and-todos" tabindex="-1"><a class="header-anchor" href="#injecting-highlighting-for-urls-and-todos" aria-hidden="true">#</a> Injecting highlighting for URLs and TODOs</h3><p>Two built-in packages called <code>language-todo</code> and <code>language-hyperlink</code> define specialized TextMate grammars. Their purpose is to provide rules that match <code>TODO:</code> remarks (in comments) and URLs (in comments and strings), and to inject those rules into certain contexts <em>regardless of grammar</em>. This is a lovely feature of TextMate that the Atom developers got for free when implementing TextMate-style grammars back in the day.</p><p>The effect is that Pulsar can help you locate TODOs in comments by coloring them differently from the rest of the comment. It can also draw underlines under URLs and even <em>follow</em> a URL when you place your cursor inside of it and invoke the <strong>Link: Open</strong> command.</p><p><img src="`+v+`" alt="illustration of highlighting of TODOs and URLs in a line comment"></p><p>This works because a TextMate grammar can \u201Cpush\u201D its injections into any scope <em>inside any other grammar</em>, whether that other grammar asks for it or not. For instance, the <code>language-hyperlink</code> grammar injects itself into strings, so any language that defines a <code>string.*</code> scope will have those rules injected into it.</p><p>The legacy Tree-sitter system never had an equivalent feature. I missed it terribly, so I decided to create equivalent Tree-sitter parsers and grammars for these rules. These parsers, when given arbitrary text, can create nodes for things that look like URLs or TODO comments. Once those parsers existed, I could inject them into whichever grammars I wanted:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> type <span class="token keyword">of</span> <span class="token punctuation">[</span><span class="token string">&quot;template_string&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;string_fragment&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;comment&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	atom<span class="token punctuation">.</span>grammars<span class="token punctuation">.</span><span class="token function">addInjectionPoint</span><span class="token punctuation">(</span><span class="token string">&quot;source.js&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
		type<span class="token punctuation">,</span>
		<span class="token function-variable function">language</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token string">&quot;hyperlink&quot;</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token punctuation">,</span>
		<span class="token function-variable function">content</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> node<span class="token punctuation">,</span>
		<span class="token literal-property property">languageScope</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>There\u2019s one new thing here: the <code>languageScope</code> option. Typically, you\u2019ll want a grammar\u2019s base scope name to be present inside of an injection; for instance, you\u2019d want a <code>source.js</code> scope name to exist inside of an HTML <code>script</code> block. But that behavior doesn\u2019t make sense for our use case. We want to add a scope name around a URL when it\u2019s present, but otherwise we want to operate stealthily. Passing <code>null</code> to the <code>languageScope</code> option lets us bypass the default behavior.</p><p>There\u2019s one other thing to address, though. Most comments <em>won\u2019t</em> have URLs in them. Most strings <em>won\u2019t</em> have URLs in them. If I use this code as-is, I\u2019ll be creating one new injection for every string, every line comment, and every block comment in my JavaScript file, whether a URL is present or not. (This unnecessary work, believe it or not, doesn\u2019t create any sluggishness during routine editing, but we should still try to avoid it.)</p><p>What should I do? One option would be to do what I described above: create one large injection for the entire document and have it be in charge of all comments and strings in the document. That was my first experiment, but I decided against it because the trade-off wasn\u2019t worth it: incremental re-parses were <em>slower</em> because every buffer change meant that my URL parser had to re-scan the whole buffer.</p><p>I\u2019m willing to chalk part of that up to my lack of experience writing Tree-sitter parsers! I\u2019d bet there are things I can do to make those parses less costly. But in the meantime, I applied a Stupid Human Trick\u2122 to get the best of both worlds:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token constant">HYPERLINK_PATTERN</span> <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\\bhttps?:</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> type <span class="token keyword">of</span> <span class="token punctuation">[</span><span class="token string">&quot;template_string&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;string_fragment&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;comment&quot;</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	atom<span class="token punctuation">.</span>grammars<span class="token punctuation">.</span><span class="token function">addInjectionPoint</span><span class="token punctuation">(</span><span class="token string">&quot;source.js&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
		type<span class="token punctuation">,</span>
		<span class="token function-variable function">language</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token constant">HYPERLINK_PATTERN</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>text<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">&quot;hyperlink&quot;</span> <span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token punctuation">,</span>
		<span class="token function-variable function">content</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> node<span class="token punctuation">,</span>
		<span class="token literal-property property">languageScope</span><span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>I can assure you that this feels <em>incredibly</em> silly to do, but it works: we\u2019re pre-screening the content of the node and ignoring those that definitely don\u2019t contain a URL. Returning <code>undefined</code> from the <code>language</code> callback prevents a layer from being needlessly created. We employ a similar strategy for the <code>TODO</code> highlighting.</p><p>There\u2019s another thing that feels awkward about this: it\u2019s not as <em>automatic</em> as the previous TextMate solution. Instead of being able to \u201Cpush\u201D these injections into other grammars, we\u2019re asking those grammars to \u201Cpull\u201D our injections into themselves.</p><p>In an ideal world, I\u2019d be able to create a generalized injection that applied to <em>all</em> files as easily as in the TextMate grammars. But to create a Tree-sitter injection I\u2019ve got to describe the <em>name of the node</em> I want to inject into. And there aren\u2019t many safe assumptions you can make about Tree-sitter node naming conventions.</p><p>The saving grace here is what I mentioned above: the injection API lets you inject things into someone else\u2019s language grammar. So if your favorite community language package doesn\u2019t highlight TODOs and URLs, you can fix that with about six lines of JavaScript in your <code>init.js</code>.</p><h3 id="markdown-and-front-matter" tabindex="-1"><a class="header-anchor" href="#markdown-and-front-matter" aria-hidden="true">#</a> Markdown and front matter</h3>`,55),W={href:"https://jekyllrb.com/",target:"_blank",rel:"noopener noreferrer"},Y={href:"https://jekyllrb.com/docs/step-by-step/03-front-matter/",target:"_blank",rel:"noopener noreferrer"},E={href:"https://github.com/MDeiml/tree-sitter-markdown",target:"_blank",rel:"noopener noreferrer"},U={href:"https://github.com/ikatyang/tree-sitter-markdown",target:"_blank",rel:"noopener noreferrer"},F=a("em",null,"doesn\u2019t",-1),z=a("em",null,"bulletproof",-1),V=a("p",null,"So how do we get around the older parser\u2019s lack of support for front matter? By writing our own Tree-sitter parser and using injections:",-1),G={href:"https://github.com/savetheclocktower/tree-sitter-frontmatter",target:"_blank",rel:"noopener noreferrer"},K=a("li",null,"Inject the YAML grammar into the front matter node.",-1),$=a("li",null,"Inject the Markdown grammar into the Markdown text node.",-1),X=a("p",null,[n("In an ideal world, the parser in step 1 would be just an ordinary Tree-sitter parser for Markdown, and we\u2019d need only the single injection for the YAML block. But this\u2019ll tide us over just fine. Documents that don\u2019t have front matter still get parsed by "),a("code",null,"tree-sitter-frontmatter"),n(" and will simply omit the "),a("code",null,"front_matter"),n(" node.")],-1),Q=a("h2",{id:"next-time",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#next-time","aria-hidden":"true"},"#"),n(" Next time")],-1),Z={href:"https://tree-sitter.github.io/tree-sitter/code-navigation-systems",target:"_blank",rel:"noopener noreferrer"};function nn(an,tn){const t=l("ExternalLinkIcon");return i(),p("div",null,[b,y,c(" more "),w,a("p",null,[n("The Tree-sitter CLI tool performs its own code highlighting, so it needs "),a("a",j,[n("its own solution for injections"),s(t)]),n(". It envisions a query file called "),T,n(" that maps certain tree nodes to certain languages. For instance, here\u2019s the HTML parser\u2019s "),_,n(":")]),x,a("p",null,[n("These are simple examples, but the website documentation covers more advanced scenarios. For instance, the name of the language might not be hard-coded in the query file; it might be something that you\u2019ll need to determine from the tree itself, like by inspecting a "),a("a",q,[n("heredoc string"),s(t)]),n("\u2019s tag:")]),I,a("ol",null,[S,a("li",null,[n("There are multiple use cases for associating a shorthand token in a buffer file to a language name. I mentioned above how "),a("a",L,[n("heredoc strings"),s(t)]),n(" often hint at the language of the string content via the tag. (And as I write this document, I glance at a dozen other examples: fenced code blocks in Markdown.) So it\u2019s useful for us to be able to determine the to-be-injected language dynamically by inspecting the content of the buffer. We need to meet those use cases where they are.")])]),a("p",null,[n("So when an injection wants "),M,n(", we need to be able to match it to our "),P,n(" grammar. That happens via "),a("a",H,[n("a property in the grammar definition file"),s(t)]),n("; the grammar itself describes its \u201Cshort\u201D name.")]),C,O,a("p",null,[n("To visualize what we described above, you can once again use "),a("a",A,[n("tree-sitter-tools"),s(t)]),n(". Open your favorite HTML document, then run the "),R,n(" command. You\u2019ll be able to see all of a document\u2019s trees in a drop-down list:")]),D,a("p",null,[n("The systems we described in the last two installments \u2014 "),a("a",J,[n("syntax highlighting"),s(t)]),n(", "),a("a",N,[n("code folding, and indentation hinting"),s(t)]),n(" \u2014\xA0are much easier to explain when we don\u2019t have to think about injections. How do we make them work in a multi-language buffer?")]),B,a("p",null,[n("Markdown is how I write most of my prose, including this blog post. And for years it\u2019s been quite popular inside static site generators like "),a("a",W,[n("Jekyll"),s(t)]),n(" and its successors, but with a wrinkle: those tools support the addition of YAML metadata via "),a("a",Y,[n("a \u201Cfront matter\u201D block"),s(t)]),n(" at the start of a Markdown file.")]),a("p",null,[n("There are two major Markdown parsers for Tree-sitter, both of which are written by third parties rather than by the Tree-sitter organization. "),a("a",E,[n("One of them"),s(t)]),n(" is being actively developed, and boasts built-in support for front matter, but has a number of bugs that are show-stoppers for Pulsar at the moment. "),a("a",U,[n("The other one"),s(t)]),n(" is older, "),F,n(" support front matter, and doesn\u2019t seem to be actively maintained\u2026 but is otherwise "),z,n(". I\u2019d love to use the newer one for Pulsar, but I can\u2019t justify it until it\u2019s more stable.")]),V,a("ol",null,[a("li",null,[a("a",G,[n("Write a front matter parser"),s(t)]),n(" whose only purpose is to divide a Markdown document into two nodes: (a) front matter and (b) Markdown text.")]),K,$]),X,Q,a("p",null,[n("I could keep talking about injections, but I can\u2019t afford to test your patience while we still have other topics to visit. Next time we\u2019ll look at what Tree-sitter calls "),a("a",Z,[n("code navigation systems"),s(t)]),n(": how to use Tree-sitter to identify functions, classes, and other important parts of your code.")])])}const en=o(f,[["render",nn],["__file","20231110-savetheclocktower-modern-tree-sitter-part-5.html.vue"]]);export{en as default};
