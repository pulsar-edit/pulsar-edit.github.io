import{_ as r,o as n,c as i,a as t,b as e,d as a,e as h,f as s,r as l}from"./app.87197fef.js";const d={},c={href:"https://tree-sitter.github.io/tree-sitter/",target:"_blank",rel:"noopener noreferrer"},u=t("em",null,"mundane",-1),p=s('<p>Tree-sitter is a typical open-source project: the sky\u2019s the limit, but there\u2019s never quite enough time and attention to go around.</p><p>I think it\u2019s absolutely amazing what we on the Pulsar team have been able to do in such a short amount of time \u2014 especially when using the <code>web-tree-sitter</code> bindings, which appear to be nobody\u2019s first choice. Still, there have been bumps in the road. Maybe I can point out a few of them and help out the next Tree-sitter user.</p><p>Since I <em>do not</em> want to save any of these gripes for an <em>eighth</em> blog post (and since you probably don\u2019t want to <em>read</em> an eighth blog post) this article may be a bit longer than the rest.</p><p>Don\u2019t get me wrong: nearly all of these challenges have gotten easier in the year that I\u2019ve been immersed in Tree-sitter. There is cause for optimism, and I\u2019ll be sure to point out the upsides as I go.</p><h2 id="tree-sitter-challenges" tabindex="-1"><a class="header-anchor" href="#tree-sitter-challenges" aria-hidden="true">#</a> Tree-sitter challenges</h2><p>I\u2019ve tried to group these gripes based on how generally applicable they are. Some of them would be things <em>you\u2019d</em> trip over if you started using Tree-sitter tomorrow, and some might just be Pulsar-specific dilemmas. In order to keep you engaged, let\u2019s start with the broader gripes.</p><h3 id="it-s-nobody-s-day-job" tabindex="-1"><a class="header-anchor" href="#it-s-nobody-s-day-job" aria-hidden="true">#</a> It\u2019s nobody\u2019s day job</h3>',7),m={href:"https://github.com/maxbrunsfeld",target:"_blank",rel:"noopener noreferrer"},g=t("p",null,[t("em",null,"Lots"),e(" of major improvements happen "),t("em",null,"in between"),e(" major releases. For this reason, most of Pulsar\u2019s own Tree-sitter grammars are built from the "),t("code",null,"master"),e(" branch of their parsers, rather than from tagged releases on NPM.")],-1),f={href:"https://nova.app/",target:"_blank",rel:"noopener noreferrer"},b=t("p",null,"So it\u2019s not going anywhere, and enough people know how it works that it\u2019d have a future even if Max suddenly decided to eschew modern technology and go live simply in the woods.",-1),y=t("em",null,"could",-1),w={href:"https://zed.dev/",target:"_blank",rel:"noopener noreferrer"},v=t("h4",{id:"and-yet",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#and-yet","aria-hidden":"true"},"#"),e(" And yet\u2026")],-1),_={href:"https://github.com/tree-sitter",target:"_blank",rel:"noopener noreferrer"},k=t("code",null,"tree-sitter",-1),x={href:"https://github.com/amaanq",target:"_blank",rel:"noopener noreferrer"},T={href:"https://github.com/clason",target:"_blank",rel:"noopener noreferrer"},I={href:"https://github.com/sogaiu",target:"_blank",rel:"noopener noreferrer"},S={href:"https://discord.gg/w7nTvsVJhm",target:"_blank",rel:"noopener noreferrer"},j={href:"https://matrix.to/#/#tree-sitter-chat:matrix.org",target:"_blank",rel:"noopener noreferrer"},A=s('<p>The presence of other diligent contributors is how Tree-sitter has gotten much better over that span of time despite only sporadic participation from Max.</p><p>There\u2019s even a roadmap these days \u2014 which would\u2019ve been a shocking display of transparency even six months ago! Things are looking up.</p><h3 id="it-s-hard-easy-hard-to-write-parsers" tabindex="-1"><a class="header-anchor" href="#it-s-hard-easy-hard-to-write-parsers" aria-hidden="true">#</a> It\u2019s <s>hard</s> <s>easy</s> hard to write parsers</h3><p>I could argue both sides of this one depending on how I chose to look at it.</p><p>It\u2019s easy to <em>start</em> writing a Tree-sitter parser. At the beginning, you\u2019re staring at a largely empty JavaScript file. Each individual rule seems easy to add. You keep adding new rules, then testing them, and everything works. You think this is going to be a cake-walk.</p><p>Ten minutes later, you\u2019ve hit a wall. You\u2019re staring at some debugging output, trying to figure out how the last rule you added somehow broke everything.</p><p>This is quite common! The learning curve of Tree-sitter is\u2026 shaped much more strangely than a curve.</p><p>Why is this true? And what can be done about it?</p>',8),P=s("<li><p>First, the design: Tree-sitter is a <em>style</em> of parser that many people will be unfamiliar with. It doesn\u2019t backtrack and it doesn\u2019t try to group simple nodes into higher-level constructs until <em>after</em> it\u2019s decided what kinds of nodes they are. This violates a lot of folks\u2019 intuitions about how something should parse. To a certain extent, this is unavoidable, though there are a few loopholes that we\u2019ll discuss in a moment.</p></li><li><p>There are two important tools to help you understand the parsing process. <code>tree-sitter --debug</code> will give you exhaustive logging of each step of the parse process; and <code>tree-sitter -D</code> will go further and actually <em>build graphs</em> to visualize chains of tokens, opening the results in a web page when the parse is done.</p><p>These are great tools, but they output the kind of debug information that you\u2019d want if you already knew <em>exactly how Tree-sitter worked</em> and didn\u2019t need any of its decisions explained. There are improvements to be made here.</p></li>",2),C=t("em",null,"mother of all loopholes",-1),M={href:"https://tree-sitter.github.io/tree-sitter/creating-parsers#external-scanners",target:"_blank",rel:"noopener noreferrer"},W={href:"https://tree-sitter.github.io/tree-sitter/creating-parsers#other-external-scanner-details",target:"_blank",rel:"noopener noreferrer"},q=t("p",null,[e("The power that this gives a parser author is certainly appreciated, but it tempts parser authors to define more rules externally instead of inside "),t("code",null,"grammar.js"),e(". When I resort to external scanner logic to get me out of a jam, I always suspect that there\u2019s a simpler way to solve the problem that I just don\u2019t understand.")],-1),B=t("p",null,"And if you\u2019re like me and you have no real experience in systems programming, you might be intimidated by a system that expects you to dip into C to solve some of your problems.",-1),E=s('<h4 id="and-yet-1" tabindex="-1"><a class="header-anchor" href="#and-yet-1" aria-hidden="true">#</a> And yet\u2026</h4><p>I\u2019ve had a draft of this blog post half-written for six months, but when I first wrote it, I would never have dreamed that I\u2019d be such an active contributor to the Tree-sitter ecosystem by now.</p><p>Despite not feeling like I\u2019ve got my brain totally wrapped around this whole parser thing, I\u2019ve now written three small parsers from scratch, and am maintaining a fork of <code>tree-sitter-scss</code>. I\u2019ve contributed bug fixes and enhancements to <code>tree-sitter-jsdoc</code>, <code>tree-sitter-html</code>, and <code>tree-sitter-css</code>.</p>',3),R=t("em",null,"lexing",-1),z=t("em",null,"parsing",-1),O={href:"https://tree-sitter.github.io/tree-sitter/creating-parsers#conflicting-tokens",target:"_blank",rel:"noopener noreferrer"},D=t("em",null,"lexing",-1),H=t("p",null,[e("It\u2019s true that the prospect of having to write C steepens the learning curve a bit. But the C that you\u2019d write for an external scanner really isn\u2019t that challenging! The vast majority of it involves "),t("code",null,"while"),e(" loops and "),t("code",null,"switch"),e(" statements and comparing characters to other characters. The most challenging problem I\u2019ve tackled in an external scanner is keeping track of state \u2014 and there are plenty of examples of scanners that keep state that you can crib from.")],-1),N={href:"https://discord.gg/w7nTvsVJhm",target:"_blank",rel:"noopener noreferrer"},L=t("em",null,"incredibly",-1),G=t("p",null,"With help, and over time, even the most intimidating tools slowly reveal their inner workings. If I can do it, so can you.",-1),U=t("h3",{id:"the-web-tree-sitter-experience-is-second-class",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#the-web-tree-sitter-experience-is-second-class","aria-hidden":"true"},"#"),e(" The "),t("code",null,"web-tree-sitter"),e(" experience is second-class")],-1),Y=t("code",null,"web-tree-sitter",-1),V={href:"https://webassembly.org/",target:"_blank",rel:"noopener noreferrer"},F=t("em",null,"ten-fold",-1),J=t("code",null,"node-tree-sitter",-1),K=t("p",null,[e("In fact, most of the challenges we\u2019ve faced with "),t("code",null,"web-tree-sitter"),e(" don\u2019t involve performance at all: they involve constraints on the web platform that don\u2019t affect other bindings.")],-1),Q=t("h4",{id:"stdlib-exports",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#stdlib-exports","aria-hidden":"true"},"#"),e(" stdlib exports")],-1),X=t("code",null,"web-tree-sitter",-1),Z={href:"https://emscripten.org/",target:"_blank",rel:"noopener noreferrer"},$=t("code",null,"#import <wctype.h>",-1),ee=t("code",null,"iswspace",-1),te=t("code",null,"web-tree-sitter",-1),oe=t("code",null,"web-tree-sitter",-1),ae=t("em",null,"guess",-1),se={href:"https://github.com/tree-sitter/tree-sitter/blob/53cc93c267f473d82c22dbd6d4250653652d3eba/lib/src/wasm/stdlib-symbols.txt",target:"_blank",rel:"noopener noreferrer"},re=t("em",null,"not",-1),ne=t("p",null,[e("If you do a thorough audit of a parser, you can make note of which builtins it\u2019ll need. But some parsers have "),t("em",null,"quite complex"),e(" external C scanners. And if you overlook one, you won\u2019t find out until runtime.")],-1),ie=t("p",null,"Architecturally, Tree-sitter is fixing this by setting firmer rules about which functions you can and can\u2019t use in an external scanner; that list I linked above is now a mandate. But I expect that it\u2019ll be a while before parsers in the wild are updated to reflect this.",-1),he={href:"https://github.com/pulsar-edit/pulsar/blob/master/vendor/web-tree-sitter/README.md",target:"_blank",rel:"noopener noreferrer"},le=t("code",null,"web-tree-sitter",-1),de=t("em",null,"all",-1),ce=t("p",null,"And it means that, if a community package wants to contribute a Tree-sitter grammar, its author might run up against this problem and have to open a ticket with Pulsar to get us to add new functions to the exports list. We\u2019d be happy to do so, but then the author would have to wait around for the next stable Pulsar release, and all Pulsar users would have to update to that release before they could install that package.",-1),ue=t("h4",{id:"emscripten-versioning",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#emscripten-versioning","aria-hidden":"true"},"#"),e(" Emscripten versioning")],-1),pe={href:"https://github.com/sogaiu/ts-questions/blob/master/questions/which-version-of-emscripten-should-be-used-for-the-playground/README.md",target:"_blank",rel:"noopener noreferrer"},me=s('<p>It also means that we have to keep our build of <code>web-tree-sitter</code> pretty diligently up to date. My experience is that newer versions of <code>web-tree-sitter</code> can consume parsers built against earlier versions, but not <em>vice versa</em>. I\u2019m glad to have backward compatibility, but it does make it rather urgent for us to ensure our <code>web-tree-sitter</code> is as new as possible so that community packages don\u2019t have to build their <code>.wasm</code> files with older versions of the <code>tree-sitter</code> CLI.</p><h4 id="lack-of-custom-predicates" tabindex="-1"><a class="header-anchor" href="#lack-of-custom-predicates" aria-hidden="true">#</a> Lack of custom predicates</h4>',2),ge=t("code",null,"web-tree-sitter",-1),fe={href:"https://github.com/tree-sitter/tree-sitter/issues/2904",target:"_blank",rel:"noopener noreferrer"},be=t("p",null,[e("Until then, our only way of defining custom query logic is by attaching properties to the "),t("code",null,"#is?"),e(" and "),t("code",null,"#is-not?"),e(" predicates and doing our own \u201Cpost-processing\u201D step on the matches that Tree-sitter gives us.")],-1),ye=t("h4",{id:"and-yet-2",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#and-yet-2","aria-hidden":"true"},"#"),e(" And yet\u2026")],-1),we=t("p",null,[e("Whatever problems we\u2019ve had with "),t("code",null,"web-tree-sitter"),e(" haven\u2019t prevented us from shipping a bunch of solid parsers that have held up to stress-testing. (Our biggest problem so far has been with our Markdown parser, and we fixed that by migrating to another Tree-sitter Markdown parser that\u2019s more actively maintained.)")],-1),ve={href:"https://github.com/tree-sitter/tree-sitter/pull/1864",target:"_blank",rel:"noopener noreferrer"},_e=t("code",null,".wasm",-1),ke=t("code",null,".wasm",-1),xe=t("code",null,"web-tree-sitter",-1),Te=s('<p>Tree-sitter has also been cracking the whip on external scanners recently; C++ external scanners have been deprecated, and (as mentioned earlier) scanner authors no longer have freedom to use anything they want from the C stdlib. Practically speaking, this isn\u2019t a hardship; if anything, a lack of prescription from Tree-sitter was leading to sloppy choices. (For instance, some parsers wrongly use <code>isalpha</code> instead of <code>iswalpha</code> \u2014\xA0the latter being more proper for Unicode text.)</p><p>And the feedback loop is getting shorter: you will now be warned <em>at compile time</em> when you try to make a <code>.wasm</code> file from a parser that consumes functions that are not in the default list of exports.</p><h3 id="error-recovery-is-a-black-box" tabindex="-1"><a class="header-anchor" href="#error-recovery-is-a-black-box" aria-hidden="true">#</a> Error recovery is a black box</h3><p>Tree-sitter is <em>not</em> a fail-on-first-error sort of parser. That strategy would make it completely unsuitable for the task of syntax highlighting in an editor. Imagine adding a new style rule in the middle of a CSS file\u2026 and having everything after the cursor flicker as you type, because it\u2019s reacting to the fact that the CSS file is invalid until you\u2019re mostly done typing.</p>',4),Ie=t("code",null,"ERROR",-1),Se=t("code",null,"MISSING",-1),je={href:"https://github.com/tree-sitter/tree-sitter/issues/224#issuecomment-436731626",target:"_blank",rel:"noopener noreferrer"},Ae=t("em",null,"least costly way",-1),Pe=t("code",null,"ERROR",-1),Ce=t("code",null,"MISSING",-1),Me=s(`<p>The fact that this process exists is what makes Tree-sitter good for a code editor scenario in which a document frequently flips between \u201Cvalid\u201D and \u201Cinvalid.\u201D When it works well, your syntax highlighting is only minimally affected by the invalidity.</p><p>But the fact that it\u2019s <em>largely a black box</em> is frustrating, especially in rare scenarios in which Tree-sitter makes a catastrophically bad choice in how to recover. The \u201Ccosts\u201D of various error recovery strategies are determined by Tree-sitter in ways that may not make much sense to an outside observer.</p><p>Here\u2019s a very simple example from the <code>tree-sitter-css</code> parser:</p><div class="language-css ext-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">div</span> <span class="token punctuation">{</span>
  justif
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>If your cursor is at the end of <code>justif</code>, you\u2019re probably about to type something like <code>y-content: space-between;</code>. Because of recent enhancements to CSS, the <code>justif</code> token could turn out to be one of several things\u2026 but it\u2019s probably just a property name! And the parser should assume it\u2019s a property name until it\u2019s certain that it isn\u2019t.</p><p>Yet <code>tree-sitter-css</code> doesn\u2019t parse it this way:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>(stylesheet [0, 0] - [3, 0]
  (rule_set [0, 0] - [2, 1]
    (selectors [0, 0] - [0, 3]
      (tag_name [0, 0] - [0, 3]))
    (block [0, 4] - [2, 1]
      (ERROR [1, 2] - [1, 6]
        (attribute_name [1, 2] - [1, 8])))))
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,7),We=t("code",null,"justif",-1),qe=t("code",null,"justif",-1),Be={href:"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_nesting/Using_CSS_nesting",target:"_blank",rel:"noopener noreferrer"},Ee=t("em",null,"isn\u2019t valid",-1),Re=t("p",null,[e("There are various annoyances like this in the "),t("code",null,"tree-sitter-css"),e(" parser. Maybe they can be fixed without new Tree-sitter features, but to me it doesn\u2019t seem like "),t("code",null,"tree-sitter-css"),e(" is poorly written; it\u2019s just that CSS itself may be designed in a way that makes it especially susceptible to the downsides of Tree-sitter\u2019s design decisions.")],-1),ze=t("p",null,[e("This is especially painful because the "),t("code",null,"autocomplete-css"),e(" package tries to inspect scope information to determine which completions to suggest at the position of the cursor. The legacy TextMate-style grammar is much better at interpreting incomplete lines than the modern Tree-sitter CSS grammar, so this isn\u2019t just a cosmetic issue; it means that Pulsar is now worse at suggesting CSS completions. (We have tentative plans to address this by no longer using scope information as the primary driver of suggestion information, but it hasn\u2019t gotten the necessary attention yet.)")],-1),Oe=t("p",null,[e("This is something that "),t("em",null,"must"),e(" get better if Tree-sitter wants to realize its potential. Hence there are two different requests I\u2019d like to make as an occasional parser author:")],-1),De={href:"https://github.com/tree-sitter/tree-sitter/issues/2404",target:"_blank",rel:"noopener noreferrer"},He=t("li",null,[e("Allow authors to anticipate certain common invalidities and handle them by returning explicit "),t("code",null,"ERROR"),e(" and "),t("code",null,"MISSING"),e(" tokens.")],-1),Ne=t("p",null,"Of these two requests, the first feels much more reasonable. I haven\u2019t fleshed out how the second idea would work, or even whether it\u2019s a good idea; it could just be a footgun.",-1),Le=t("p",null,[e("But I know "),t("em",null,"exactly"),e(" how I want Tree-sitter to parse the incomplete CSS above, and it\u2019s frustrating that I can\u2019t just "),t("em",null,"say"),e(" so.")],-1),Ge=t("h4",{id:"and-yet-3",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#and-yet-3","aria-hidden":"true"},"#"),e(" And yet\u2026")],-1),Ue={href:"https://github.com/tree-sitter/tree-sitter/issues/1870#issuecomment-1248659929",target:"_blank",rel:"noopener noreferrer"},Ye=t("em",null,"only in Max\u2019s mind",-1),Ve=t("em",null,"bottlenecks",-1),Fe=t("p",null,"For selfish reasons, I\u2019m highly interested in this getting done, but if I wanted it done on my timetable I probably should have majored in computer science instead of journalism.",-1),Je=t("h3",{id:"you-re-at-the-mercy-of-the-parser-author",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#you-re-at-the-mercy-of-the-parser-author","aria-hidden":"true"},"#"),e(" You\u2019re at the mercy of the parser author")],-1),Ke=t("p",null,"Suppose TypeScript introduces a new syntactic construct in a minor version, and suppose you\u2019re a diligent TypeScript user who starts using the new version on day one. Will your syntax highlighting be ready for the new feature?",-1),Qe=t("p",null,[e("In this example, you\u2019re in luck: since the TypeScript release process is so gradual, chances are good that the "),t("code",null,"tree-sitter-typescript"),e(" parser will have been updated to support the new syntax on day one. Pulsar releases monthly, which should mean plenty of lead time for us to see the changes to "),t("code",null,"tree-sitter-typescript"),e(" and generate a new parser for the next release.")],-1),Xe=t("code",null,"tree-sitter",-1),Ze={href:"https://sass-lang.com/",target:"_blank",rel:"noopener noreferrer"},$e={href:"https://github.com/serenadeai/tree-sitter-scss",target:"_blank",rel:"noopener noreferrer"},et={href:"https://github.com/savetheclocktower/tree-sitter-scss/",target:"_blank",rel:"noopener noreferrer"},tt=t("em",null,"enthusiastic",-1),ot={href:"https://github.com/tree-sitter/tree-sitter-bash",target:"_blank",rel:"noopener noreferrer"},at=t("code",null,"tree-sitter-bash",-1),st=t("em",null,"writers",-1),rt=t("em",null,"tried to understand",-1),nt=t("p",null,"All of these headaches could just as easily apply to a TextMate grammar, of course. But because TextMate grammars are less ambitious, they tend to recover better from constructs they don\u2019t understand, and they tend to be easier to fix than Tree-sitter grammars because they don\u2019t require such deep understanding of their internals.",-1),it=t("h4",{id:"and-yet-4",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#and-yet-4","aria-hidden":"true"},"#"),e(" And yet\u2026")],-1),ht=t("p",null,"Everything\u2019s obscure and inscrutable until it isn\u2019t. History teaches us that the way out of this dilemma is to get more people using and depending on Tree-sitter \u2014\xA0something that\u2019s already happening on its own.",-1),lt={href:"https://github.com/tree-sitter-grammars/",target:"_blank",rel:"noopener noreferrer"},dt=t("code",null,"tree-sitter-grammars",-1),ct=t("code",null,"tree-sitter",-1),ut=t("code",null,"tree-sitter-scss",-1),pt=s('<p>Many of the most high-profile third-party Tree-sitter grammars have migrated to the <code>tree-sitter-grammars</code> organization in the last few months. It\u2019s a small gesture, but it helps reassure me that those grammars won\u2019t just languish if their original authors stop contributing.</p><h2 id="pulsar-specific-challenges" tabindex="-1"><a class="header-anchor" href="#pulsar-specific-challenges" aria-hidden="true">#</a> Pulsar-specific challenges</h2><p>Now we\u2019re getting into challenges that might only be <em>laid bare</em> by Tree-sitter. A less flattering heading might have read <em>Corners we\u2019ve painted ourselves into</em>.</p><h3 id="memory-needs-managing" tabindex="-1"><a class="header-anchor" href="#memory-needs-managing" aria-hidden="true">#</a> Memory needs managing</h3><p>When you work with WebAssembly for the first time, it may surprise you to learn that you\u2019ll probably need to manage your own memory.</p><p>JavaScript developers have it pretty easy when trying to prevent memory leaks: they can rely on garbage collection once an object has no more strong references to it. But WebAssembly operates outside of the engine\u2019s standard GC process and requires <em>explicit</em> freeing of resources. A WASM module will be allocated a certain amount of memory when loaded; the author can choose the size of that allocation and whether it can grow over time. But once the module hits its maximum allowable memory usage, <em>that\u2019s it</em>. Any further attempts to allocate will trigger exceptions.</p><p>In <code>web-tree-sitter</code>, if I call <code>parse</code> on a buffer and get back a tree object, I am now <em>in charge</em> of the lifecycle of that object. The memory that has been allocated to build that object cannot be reused <em>until</em> I destroy that object. I can\u2019t just null out a variable reference and rely on the engine to take care of it.</p><p>Tree-sitter gives us the tools we need here; every tree holds a <code>delete</code> method that will dispose of it and free the associated memory. Since trees are created and thrown away with each keystroke, this is <em>incredibly</em> important for Pulsar to keep track of. When a tree is stale, we must explicitly dispose of it. Indentation hinting sometimes forces us to do an extra middle-of-transaction tree parse; if that happens, we have to save a reference to it until the next parsing cycle and clean it up along with the other stale trees.</p><p>And if a community package wants to hook into the Tree-sitter lifecycle to do something cool, it can\u2019t just keep a reference to a parsed tree and assume it\u2019ll hang around forever. If it tries, it will discover later that the tree is a useless stub of its former self because we called <code>delete</code> on it. Instead, it must first <code>await</code> until a fresh parsed tree is available \u2014 often one will be available immediately, but not always. Then it must choose between (a) processing the tree synchronously <em>before</em> it has a chance to go stale, or (b) explicitly copying the tree via a <code>copy</code> method \u2014 in which case <em>it\u2019s</em> in charge of managing the life-cycle of that copy.</p><p>Tree-sitter is a major opportunity for community packages; they can query the tree just as easily as Pulsar core. But it\u2019s also a dilemma for the Pulsar team, because it\u2019s not clear how to expose this to package authors. They deserve to have access to parsing information, but we also don\u2019t want a community package to break because of a breaking API change in <code>web-tree-sitter</code>.</p><p>Ultimately \u2014 whether we offer community packages direct access to the tree or mediate it via some sort of wrapper \u2014 it\u2019s not possible to conceal these quirks from package authors. The Pulsar API has taught them to be dutiful about resource management with <code>Disposable</code> objects and <code>onDidDestroy</code> callbacks\u2026 but this is another level entirely. If you want to do anything clever with Tree-sitter in a package, please bear it in mind.</p><h4 id="and-yet-5" tabindex="-1"><a class="header-anchor" href="#and-yet-5" aria-hidden="true">#</a> And yet\u2026</h4>',12),mt={href:"https://developer.chrome.com/blog/wasmgc/",target:"_blank",rel:"noopener noreferrer"},gt=s('<p>As far as I understand, we wouldn\u2019t get this for free; we\u2019d need <code>web-tree-sitter</code> to support it, and we\u2019d only reap the benefits once we can move to a modern Electron version. But it\u2019s still refreshing to envision a future in which dealing with a WASM library feels <em>less</em> like trying to solve a Rubik\u2019s cube while wearing rubber dishwashing gloves.</p><p>(One reason we might not want to offer direct access to <code>web-tree-sitter</code> APIs is to preserve the option of migrating back to <code>node-tree-sitter</code> in the future. But there were recent efforts to harmonize the API differences between the two bindings, so that might make life easier for our future selves.)</p><h3 id="parsing-performance-needs-managing" tabindex="-1"><a class="header-anchor" href="#parsing-performance-needs-managing" aria-hidden="true">#</a> Parsing performance needs managing</h3><p>For the vast majority of files that a user will edit, I believe that our modern Tree-sitter system will highlight code with at least comparable performance to the equivalent TextMate grammar system. It can handle files that are thousands of lines long; I know because the file that implements most of the systems I\u2019ve been describing is 4200 lines long, and it worked swimmingly even <em>before</em> I applied optimizations. In my experience, it applies syntax highlighting much more quickly than a TextMate grammar does when loading a large file.</p><p>But a text editor has a way of finding all of your edge cases. Under a worst-case scenario \u2014 a gigantic file with very long lines \u2014 both systems will fall down. But Tree-sitter will fall down <em>sooner</em>. That\u2019s because it\u2019s still a system that, by design, must parse the <em>entire file</em> at least once. That approach won\u2019t scale to certain kinds of files, like log files, that a user could plausibly try to open within Pulsar.</p><p>To ensure that we don\u2019t lock up the editor when faced with a monumental parsing task, Tree-sitter parses can go asynchronous. Right now, a parse is only allowed to run for <em>three milliseconds</em> at a time before we pause it so that other tasks can run.</p><p>If a parse takes more than three milliseconds, it\u2019s almost certainly the <em>initial</em> parse that happens when a file is opened. Parsing will continue for as many three-millisecond blocks as are necessary, with long enough pauses in between to ensure the UI is still responsive. And edits (even edits to <em>gigantic</em> files) are lightning-fast because most of the earlier work can be reused.</p><p>I think there\u2019s still some work to be done at determining the best compromise between <em>job time</em> (how long we let a parse run before pausing it) and <em>idle time</em> (how long we wait in between jobs to allow other code to run). Right now, idle time is very low, and I could entertain an argument for it to be increased; but if we did that, we\u2019d probably want to increase job time to compensate for it. Ultimately, the goal is that we allow the editor\u2019s display layer enough time to do the work it needs to hit its usual 60 frames per second \u2014\xA0which means we\u2019re talking about how best to spend the <em>16.67 milliseconds</em> we get to paint each frame.</p>',8),ft={href:"https://github.com/pulsar-edit/pulsar/blob/38c0b8837f9c2b43df2846d809ef5bbab0f46a9d/src/wasm-tree-sitter-language-mode.js#L1230-L1249",target:"_blank",rel:"noopener noreferrer"},bt=s('<h3 id="and-yet-6" tabindex="-1"><a class="header-anchor" href="#and-yet-6" aria-hidden="true">#</a> And yet\u2026</h3><p>I believe that raw parsing speed in <code>web-tree-sitter</code> is pretty well optimized. But I also think that, over time, the performance penalty of WebAssembly in Chromium can only decrease as more and more attention is paid to it. This is one reason why I\u2019m eager to upgrade our version of Electron and enjoy any optimizations to WASM and V8 that have landed in Chromium in the last couple of years.</p><p>And we\u2019ve got something in our back pocket: the <code>node-tree-sitter</code> bindings have (theoretically) been updated so that they can be used in Electron apps. Migrating back to <code>node-tree-sitter</code> would surely improve parsing and querying speed. But for all its headaches, <code>web-tree-sitter</code>\u2019s <code>.wasm</code> files really do make distribution easier. They don\u2019t have to be built for the user\u2019s architecture, nor rebuilt when the version of Electron changes. If we made this change, it\u2019d have to have <em>large</em> upside to justify the whiplash for grammar authors.</p><h3 id="highlighting-performance-needs-managing" tabindex="-1"><a class="header-anchor" href="#highlighting-performance-needs-managing" aria-hidden="true">#</a> Highlighting performance needs managing</h3><p>Pulsar uses an internal library called <code>text-buffer</code>. That\u2019s the library that handles buffer rendering. It uses pure DOM manipulation without a library and it\u2019s <em>fast</em>. It\u2019s one of the few things we haven\u2019t touched at all since the fork.</p><p>But one of the biggest bottlenecks in Pulsar has to do with the fact that <code>text-buffer</code> can only apply highlighting in increments of <em>buffer lines</em>. In the worst-case scenario \u2014 a large file without any newlines \u2014\xA0that means that every single change made to the buffer forces the <em>entire file</em> to be re-highlighted.</p><p>In one sense, this is a small problem; 99% of files you\u2019ll encounter in an editor have a reasonable number of characters per line. But in another sense, it\u2019s a big problem, since Pulsar is typically thoughtful enough not to waste time trying to highlight regions of the screen you won\u2019t even see. If a large file has no newlines, we\u2019ve got no choice but to try to highlight the entire thing.</p><p>This bottleneck affects all grammars alike, so it\u2019s not new information. And it\u2019s something that we could try to fix! Speaking personally, though: I think it\u2019d be a high-risk change. I\u2019d want to understand <code>text-buffer</code> much better than I currently do before taking a stab at it.</p><p>In the meantime, there are already checks in place that limit syntax highlighting on very large files. But right now, the systems we have to detect those kinds of files aren\u2019t robust enough. We disable syntax highlighting if a file exceeds a certain size, but this does nothing to address files that have extremely long lines even if the files themselves aren\u2019t enormous.</p><p>When we know a long buffer line will give us trouble, we should default the user to a plain-text grammar and offer them the choice of opting into syntax highlighting if they\u2019re willing to risk it \u2014 just like we do for large files today.</p><h4 id="and-yet-7" tabindex="-1"><a class="header-anchor" href="#and-yet-7" aria-hidden="true">#</a> And yet\u2026</h4><p>This one is wholly within Pulsar\u2019s control to fix; it\u2019s just a matter of finding time \u2014 or finding more contributors.</p><h3 id="query-predicates-and-footguns" tabindex="-1"><a class="header-anchor" href="#query-predicates-and-footguns" aria-hidden="true">#</a> Query predicates and footguns</h3><p>It\u2019s a strange gap in Tree-sitter query syntax that there\u2019s no way to test the position of an anonymous node. Because we\u2019d need that fairly often, I had to come up with a way of applying that constraint on our own. I invented conventions for applying additional tests on captures using the <code>#is?</code> and <code>#is-not?</code> predicates.</p><p>Those first few custom predicates were simple utilities that tested straightforward things about a node and how it related to the rest of the tree.</p><p>But because custom predicates are implemented in JavaScript, they\u2019re a powerful bridge into the rest of the Pulsar environment. And once I saw that they were quite fast in practice, I got bolder and wrote other sorts of predicates that integrated with other systems.</p><p>For instance, <code>test.config</code> \u2014 passing or failing a predicate based on the state of a Pulsar configuration value \u2014 feels weird because it talks to a different Pulsar system that has nothing to do with code parsing; yet the case for its existence is too strong to be denied. We\u2019ve already used it in <code>language-javascript</code> and <code>language-typescript</code> to deliver indentation hinting that\u2019s much more helpful than what we had before, but also more opinionated. So it\u2019s crucial that they be configurable \u2014 we wouldn\u2019t dare to make some of these decisions for users if they had no way to disable them.</p><p>Right now, Tree-sitter grammars can only use the predicates that we make available to them. Should we allow packages to write their own? Or would that be like giving them a loaded gun and pointing it at the <em>user\u2019s</em> foot?</p>',18),yt=t("code",null,"highlights.scm",-1),wt={href:"https://github.com/pulsar-edit/pulsar/blob/38c0b8837f9c2b43df2846d809ef5bbab0f46a9d/packages/language-css/grammars/tree-sitter/queries/highlights.scm#L189-L190",target:"_blank",rel:"noopener noreferrer"},vt=t("em",null,"big",-1),_t=t("em",null,"lots",-1),kt=t("em",null,"even more",-1),xt=s('<p>Ideally, this sort of information wouldn\u2019t live in a <code>highlights.scm</code> file. To me, if individual grammars had the ability to define their own query predicates, this would be the killer application:</p><ol><li>Define a JSON file with nothing but names of functions (or properties or whatever else), optionally grouped by some criterion.</li><li>Have a language grammar parse that file on activation and put those functions into one or more <code>Set</code>s.</li><li>Allow the language grammar to define a <code>language-foo.isKnownFunction</code> predicate that does nothing but test for presence of a function name in any of these sets.</li></ol><p>That\u2019d probably be even quicker than a regex test. It\u2019d keep the <code>highlights.scm</code> much sleeker. And it\u2019d put the source of truth into a much more maintainable structure \u2014 a JSON file \u2014 which could be used for other purposes, like autocompletion suggestions.</p><p><em>So what\u2019s the problem</em>, you might think. Well, to give a language package the ability to do a very smart thing like this, I\u2019d also have to give it the ability to do lots of <em>potentially stupid</em> things. A poorly designed custom predicate could instantly become a major drag on editor performance without it even being obvious what the culprit is. When editor performance suffers, people get annoyed! They might complain to us instead of the package author \u2014 fair, because how are they supposed to know the real source of the problem?</p><h4 id="and-yet-8" tabindex="-1"><a class="header-anchor" href="#and-yet-8" aria-hidden="true">#</a> And yet\u2026</h4><p>Ultimately, I think this is too powerful of a tool to justify not using it for our own language packages. And if our own language packages can use it, so can community packages \u2014 to do otherwise would be a violation of Pulsar\u2019s ethos.</p><p>So I think the best way forward would be to define ground rules for what custom predicates can do and how long they can take to do it \u2014 even to the extent of setting time budgets and warning when they\u2019re too slow.</p><h2 id="why-are-you-telling-me-this" tabindex="-1"><a class="header-anchor" href="#why-are-you-telling-me-this" aria-hidden="true">#</a> Why are you telling me this?</h2><p>Other than the fact that the internet is largely for complaining, what\u2019s the point of this airing of grievances?</p><p>I don\u2019t want you to misunderstand. I\u2019m now a regular Tree-sitter contributor and have just written six blog posts about how cool it is, so I\u2019m not trying to be a buzzkill here.</p><p><strong>Highlighting source code is hard!</strong> Here\u2019s how I know:</p>',11),Tt={href:"https://macromates.com/manual/en/language_grammars#naming_conventions",target:"_blank",rel:"noopener noreferrer"},It={href:"https://github.com/kkos/oniguruma",target:"_blank",rel:"noopener noreferrer"},St={href:"https://code.visualstudio.com/",target:"_blank",rel:"noopener noreferrer"},jt={href:"https://code.visualstudio.com/",target:"_blank",rel:"noopener noreferrer"},At={href:"https://vscode.dev/",target:"_blank",rel:"noopener noreferrer"},Pt={href:"https://github.com/microsoft/vscode-oniguruma",target:"_blank",rel:"noopener noreferrer"},Ct=t("p",null,[e("That\u2019s how much editor authors "),t("em",null,"don\u2019t"),e(" want to write their own syntax highlighting system. If it were easy, someone would\u2019ve done it by now!")],-1),Mt=t("p",null,[e("If you\u2019re wondering why Tree-sitter is gathering so much momentum despite being around for years and "),t("em",null,"still"),e(" not having a 1.0 release\u2026 it\u2019s because it\u2019s clearly better than what we had before, warts and all.")],-1),Wt=t("h3",{id:"you-still-haven-t-sold-me",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#you-still-haven-t-sold-me","aria-hidden":"true"},"#"),e(" You still haven\u2019t sold me")],-1),qt=t("p",null,"As this series illustrates, I\u2019m excited about the handful of ways that Tree-sitter makes Pulsar a better editor. But if you feel like you\u2019re being swept up in these grammars that you don\u2019t care much about, I want to make sure you know that there are solutions! Tree-sitter makes grammars customizable enough to accommodate even the tiniest and most arbitrary of gripes.",-1),Bt=t("code",null,"this",-1),Et={href:"https://discord.gg/7aEbB9dGRT",target:"_blank",rel:"noopener noreferrer"},Rt=s(`<p>But if it\u2019s more fundamental than that, and you just want the highlighting you were used to, then I\u2019ll state it again for safety: <strong>the original TextMate-style grammars aren\u2019t going anywhere</strong>. We\u2019re not even <em>tempted</em> to drop support for that system. It would break backward compatibility and make lots of our users unhappy\u2026 without delivering any meaningful progress in performance, complexity, or bundle size.</p><p>Nearly all built-in languages have a TextMate-style grammar you can fall back on. If a particular Tree-sitter grammar causes you pain for whatever reason, you can selectively revert to the TextMate grammar with a scope-specific setting in your <code>config.cson</code>:</p><div class="language-coffeescript ext-coffeescript line-numbers-mode"><pre class="language-coffeescript"><code><span class="token string-property property">&quot;.source.css&quot;</span><span class="token operator">:</span> <span class="token comment"># (or any other grammar)</span>
  <span class="token property">core</span><span class="token operator">:</span>
    <span class="token property">useTreeSitterParsers</span><span class="token operator">:</span> <span class="token keyword">false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>You may be relying on a <em>legacy</em> Tree-sitter grammar; and if so, I regret to tell you that that grammar <em>will</em> be going away soon. But since legacy Tree-sitter offered a very similar set of trade-offs as modern Tree-sitter does, I\u2019m much more confident that the modern version of that grammar will be able to meet your needs.</p><h2 id="you-ve-reached-the-end-of-the-series" tabindex="-1"><a class="header-anchor" href="#you-ve-reached-the-end-of-the-series" aria-hidden="true">#</a> You\u2019ve reached the end of the series</h2>`,5),zt={href:"https://discord.gg/7aEbB9dGRT",target:"_blank",rel:"noopener noreferrer"};function Ot(Dt,Ht){const o=l("ExternalLinkIcon");return n(),i("div",null,[t("p",null,[e("I\u2019ve spent a number of posts talking about "),t("a",c,[e("Tree-sitter"),a(o)]),e(" as though it makes sliced bread look "),u,e(". But it also drives me nuts on a regular basis. Let\u2019s wrap up the series by talking about what makes Tree-sitter hard to work with \u2014 with an optimistic look toward the near future.")]),h(" more "),p,t("p",null,[t("a",m,[e("Max Brunsfeld"),a(o)]),e(" worked on Tree-sitter for years before it wound up in Atom. It\u2019s no longer just his pet project \u2014 there are a small handful of folks with commit rights to the repository \u2014 but, of course, they\u2019re volunteers, and development happens on a \u201Cwhen-it\u2019s-done\u201D schedule. There\u2019s a rough roadmap of desired improvements, but not much of a timetable.")]),g,t("p",null,[e("Yet, despite this uncertainty, lots of projects have embraced Tree-sitter. One of them is "),t("a",f,[e("a commercial text editor"),a(o)]),e(". As we\u2019ve mentioned, GitHub uses Tree-sitter for code navigation and highlighting on the web. Other companies are building code analysis tools around it.")]),b,t("p",null,[e("Still, there\u2019s a mismatch here. It\u2019s becoming crucial infrastructure for major projects, yet it\u2019s nobody\u2019s full-time job. It "),y,e(" be somebody\u2019s full-time job, but the creator already has "),t("a",w,[e("that other full-time job"),a(o)]),e(", and that doesn\u2019t seem like it\u2019ll change any time soon.")]),v,t("p",null,[e("There are six official members of "),t("a",_,[e("the "),k,e(" GitHub organization"),a(o)]),e(", but I\u2019d like to mention "),t("a",x,[e("@amaanq"),a(o)]),e(" specifically as being an increasingly helpful and prolific contributor in the eighteen months that I\u2019ve spent in the Tree-sitter ecosystem. Others, like "),t("a",T,[e("@clason"),a(o)]),e(" and "),t("a",I,[e("@sogaiu"),a(o)]),e(", idle on Tree-sitter\u2019s "),t("a",S,[e(" Discord"),a(o)]),e(" and "),t("a",j,[e("Matrix"),a(o)]),e(" channels and have written enormously helpful documentation.")]),A,t("ul",null,[P,t("li",null,[t("p",null,[e("When Tree-sitter can\u2019t solve a problem on its own, you can employ the "),C,e(": you can "),t("a",M,[e("write an external scanner in C"),a(o)]),e(". An external scanner can do lots of things "),t("a",W,[e("that otherwise couldn\u2019t be done"),a(o)]),e(", because it can both keep its own state and look ahead as much as it wants.")]),q,B])]),E,t("p",null,[e("Tree-sitter got easier once I understood that most of the crucial decisions are made during "),R,e(", rather than during "),z,e(". Lexing happens first; it\u2019s the process Tree-sitter uses "),t("a",O,[e("to decide what the next token will be"),a(o)]),e(". And since there\u2019s no backtracking, it\u2019s often the root cause of a parsing problem. Headaches around precedence and ambiguity can usually be smoothed out in the parsing phase, but if the "),D,e(" is going wrong, none of the parsing-related tools that Tree-sitter gives you will help much.")]),H,t("p",null,[e("Reading the source code of other Tree-sitter parsers is probably the best way to understand Tree-sitter better, and the second-best way is to idle in "),t("a",N,[e("the Tree-sitter Discord"),a(o)]),e(". The Discord isn\u2019t "),L,e(" active, but nearly all queries get answered eventually.")]),G,U,t("p",null,[e("I consider "),Y,e(" to be one of the main success stories of "),t("a",V,[e("WebAssembly"),a(o)]),e(". Before WebAssembly, compiling a C-based library like Tree-sitter to run entirely in a browser would\u2019ve involved something closer to a "),F,e(" performance penalty. With WebAssembly, that penalty is small enough that most users won\u2019t notice the difference between it and the "),J,e(" bindings.")]),K,Q,t("p",null,[e("We\u2019ve talked about how a Tree-sitter grammar can use an external C scanner to do its job. This isn\u2019t a problem for "),X,e("; "),t("a",Z,[e("Emscripten"),a(o)]),e(" can compile those scanners to WebAssembly. But the scanner can draw on any functions it wants from the C standard library to help it with this task. This makes sense; why write a custom C function to detect if the next character is whitespace when you can just "),$,e(" and use "),ee,e("?")]),t("p",null,[e("But "),te,e(" \u2014 not an individual parser \u2014 is in charge of bundling and exporting these builtins at compile time. That\u2019s a dilemma: parsers can choose any functions they want from the C standard library, but "),oe,e(" has to "),ae,e(" which functions they\u2019ll pick. Out of the box, "),t("a",se,[e("it makes good guesses"),a(o)]),e("; but if a parser uses a function that\u2019s "),re,e(" on that list, that parser will fail at runtime when it tries to use that function and finds that it\u2019s just not available.")]),ne,ie,t("p",null,[e("Hence, for now, Pulsar has got to keep track of all the external functions that are used by popular Tree-sitter parsers, and "),t("a",he,[e("build a custom "),le,a(o)]),e(" that includes them "),de,e(". This doesn\u2019t make it bloated or slow, from what I can tell, but it is a chore.")]),ce,ue,t("p",null,[e("I\u2019m also not wild about how particular the toolchain is. Turning a parser into a WASM file involves using "),t("a",pe,[e("a precise version of Emscripten"),a(o)]),e(" that varies based on the version of Tree-sitter that the parser uses. It\u2019s not a huge problem, but it certainly steepens the learning curve for contributors.")]),me,t("p",null,[e("Other Tree-sitter bindings have the ability to define their own query predicates. This would be quite helpful for Pulsar; it\u2019d allow us to define predicates with more than a single argument and predicates that assert things about a specific capture instead of the whole query. Yet "),ge,e(" doesn\u2019t support this yet. I\u2019ve "),t("a",fe,[e("opened an issue for this"),a(o)]),e(" and it\u2019s possible I might be the one to contribute this when I get the time.")]),be,ye,we,t("p",null,[e("Also, "),t("a",ve,[e("this recent change"),a(o)]),e(" is exciting: compared to native parsers, "),_e,e(" files are self-contained and easy to use, so now even the native Tree-sitter bindings can consume them! The prospect of being able to use "),ke,e(" files in this manner means that "),xe,e(" concerns will also be relevant to Tree-sitter\u2019s Rust and C bindings.")]),Te,t("p",null,[e("Invalidity in Tree-sitter is indicated with "),Ie,e(" and/or "),Se,e(" nodes in the tree. Tree-sitter will parse some tokens, notice that they don\u2019t add up to any valid rule, and "),t("a",je,[e("decide on the "),Ae,a(o)]),e(" to get itself back to a valid state. That could mean skipping over the token that put it into an error state (producing an "),Pe,e(" node). Or it could mean assuming the presence of a node that isn\u2019t there (producing a "),Ce,e(" node).")]),Me,t("p",null,[e("Instead, it\u2019s chosen to interpret "),We,e(" as an attribute name. Faced with the theoretical ambiguity of whether "),qe,e(" will end up as a property name or a tag name (remember that "),t("a",Be,[e("you can nest CSS selectors"),a(o)]),e(" now!)\u2026 Tree-sitter has chosen a third option that "),Ee,e(" there.")]),Re,ze,Oe,t("ol",null,[t("li",null,[e("Give authors "),t("a",De,[e("the ability to influence the error recovery process"),a(o)]),e(" by hinting at the \u201Ccost\u201D of a missing or skipped token.")]),He]),Ne,Le,Ge,t("p",null,[e("This is a known issue and "),t("a",Ue,[e("it\u2019s on Max\u2019s long-term roadmap"),a(o)]),e(". The optimism is more remote here because the problems with solutions that exist "),Ye,e(" have, well, more "),Ve,e(" than other problems.")]),Fe,Je,Ke,Qe,t("p",null,[e("Now imagine you\u2019re using a more obscure parser, one written by a third party rather than maintained by the "),Xe,e(" GitHub organization. "),t("a",Ze,[e("SCSS"),a(o)]),e(" is a good example: you can see that it\u2019s got "),t("a",$e,[e("a decent parser"),a(o)]),e(", but there are lots of valid SCSS constructs that that parser doesn\u2019t support, and the last commit to the repo is thirty months old.")]),t("p",null,[e("Do you know enough about Tree-sitter to fix it yourself? And if so, what do you do if the repo is dead? Do you fork it and increase the bounds of your reluctant code ownership? (This is how I \u201Csolved\u201D the SCSS example; "),t("a",et,[e("my fork"),a(o)]),e(" fixes most of what the original repo didn\u2019t support, but I am not an "),tt,e(" maintainer.)")]),t("p",null,[e("Now suppose it isn\u2019t obscure \u2014 just especially technically challenging. Would you be up for maintaining it? (Writing a "),t("a",ot,[at,e(" parser"),a(o)]),e(" strikes me as a startling act of hubris. I think even the precious few among us who consider themselves good "),st,e(" of shell scripts would balk at writing a tool that "),rt,e(" shell scripts.)")]),nt,it,ht,t("p",null,[e("Another good sign is the emergence of the "),t("a",lt,[dt,e(" organization"),a(o)]),e(". Until recently, there were two kinds of grammars: first-party grammars that lived in the "),ct,e(" organization, and grammars that were maintained by third parties. The presence of the latter kind of grammar is promising (other people are using Tree-sitter!) but also a bit anxiety-inducing (the author could get bored or distracted at any point!), and I\u2019ve made pull requests for several third-party grammars that languished for months. (It\u2019s also why I maintain a "),ut,e(" fork.)")]),pt,t("p",null,[e("Everything I just complained about is, as of very recently, "),t("a",mt,[e("not necessarily how WebAssembly works anymore"),a(o)]),e(". More implicit strategies for garbage collection are suddenly possible.")]),gt,t("p",null,[e("Indentation hinting might be the biggest threat to that time budget. TextMate-style indentation hinting is cheap because it can just execute a regular expression against one line of content, but Tree-sitter indentation hinting requires a fresh syntax tree. Sometimes we have to reparse earlier than we otherwise would\u2019ve just to deliver accurate hinting. In the most common cases, this isn\u2019t a big deal; but some scenarios would require us to do lots of reparses in quick succession, and we\u2019ve had to develop strategies to handle those cases. (I won\u2019t bore you further with this; you can "),t("a",ft,[e("read the source code"),a(o)]),e(" if this topic fascinates you.)")]),bt,t("p",null,[e("Here\u2019s an example: the CSS and PHP grammars both have "),yt,e(" files where some scope names need to execute "),t("a",wt,[e("a "),vt,e(" regular expression"),a(o)]),e(" against the contents of a node. There are "),_t,e(" of CSS properties and values, and there are "),kt,e(" functions in PHP\u2019s large and chaotic standard library. And CSS especially is a moving target, with new properties and values added every year.")]),xt,t("ul",null,[t("li",null,[e("The most popular code editors of the past decade have highlighted your source code with "),t("a",Tt,[e("a system created 20 years ago"),a(o)]),e(" by a macOS-only editor that most people had stopped using by 2010.")]),t("li",null,[e("That system can only work alongside "),t("a",It,[e("a specific regular expression engine with ornery syntax"),a(o)]),e(".")]),t("li",null,[e("Microsoft \u2014 a huge tech company that can afford to have a team of people work on "),t("a",St,[e("a code editor that they distribute for free"),a(o)]),e(" \u2014 decided the best way to deliver a consistent highlighting experience across that editor\u2019s "),t("a",jt,[e("desktop"),a(o)]),e(" and "),t("a",At,[e("web"),a(o)]),e(" versions was to "),t("a",Pt,[e("port that obscure regular expression engine to WebAssembly"),a(o)]),e(".")])]),Ct,Mt,Wt,qt,t("p",null,[e("Even if your nitpick is as small as \u201CI want "),Bt,e(" in JavaScript to be a different color than it is\u201D\u2026 "),t("a",Et,[e("hop into Discord"),a(o)]),e(" and ask for help. We\u2019ll be able to give you the right snippet to put into your user stylesheet.")]),Rt,t("p",null,[e("If you\u2019ve read them all, give yourself a round of applause. And if you find this subject fascinating enough to have read the whole thing, and you\u2019re not already a Pulsar contributor, then I bet we could use your efforts somewhere. "),t("a",zt,[e("Visit our Discord"),a(o)]),e(" or any of the other communities listed in the menu above if you\u2019d like to have technical discussions about stuff like this.")])])}const Lt=r(d,[["render",Ot],["__file","20240902-savetheclocktower-modern-tree-sitter-part-7.html.vue"]]);export{Lt as default};
