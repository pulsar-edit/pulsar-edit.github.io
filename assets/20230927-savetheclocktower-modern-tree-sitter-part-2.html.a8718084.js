import{_ as r}from"./tree-sitter-string-scopes-diagram.2db37c5c.js";import{_ as l,o as c,c as p,a as e,b as t,d as s,w as u,e as d,f as a,r as o}from"./app.87197fef.js";const h="/assets/tree-sitter-log-cursor-scope.1a459f7a.png",m={},g=e("p",null,"Today I\u2019ll try to illustrate what that system looks like and why it\u2019s important.",-1),f={href:"https://github.com/mauricioszabo/",target:"_blank",rel:"noopener noreferrer"},b=e("code",null,"web-tree-sitter",-1),k={href:"https://github.com/tree-sitter/tree-sitter-javascript/blob/master/queries/highlights.scm",target:"_blank",rel:"noopener noreferrer"},y=e("code",null,"highlights.scm",-1),w={href:"https://tree-sitter.github.io/tree-sitter/syntax-highlighting",target:"_blank",rel:"noopener noreferrer"},v=e("code",null,"tree-sitter highlight",-1),q=e("p",null,[e("em",null,"Couldn\u2019t we just use these files and save ourselves a lot of hassle?"),t(", he asked.")],-1),_=e("p",null,"I said no. And I realized that, in saying no, I was volunteering myself to do some hard work.",-1),x=e("h2",{id:"how-textmate-grammars-work",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#how-textmate-grammars-work","aria-hidden":"true"},"#"),t(" How TextMate grammars work")],-1),T={href:"https://macromates.com/",target:"_blank",rel:"noopener noreferrer"},j={href:"https://www.sublimetext.com/",target:"_blank",rel:"noopener noreferrer"},I={href:"https://code.visualstudio.com/",target:"_blank",rel:"noopener noreferrer"},M={href:"https://en.wikipedia.org/wiki/TextMate#Language_Grammars",target:"_blank",rel:"noopener noreferrer"},S=a(`<p>Here\u2019s a very simple example of what a TextMate grammar looks like:</p><div class="language-json ext-json line-numbers-mode"><pre class="language-json"><code><span class="token punctuation">{</span>
	<span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;JavaScript&quot;</span><span class="token punctuation">,</span>
	<span class="token property">&quot;scopeName&quot;</span><span class="token operator">:</span> <span class="token string">&quot;source.js&quot;</span><span class="token punctuation">,</span>
	<span class="token property">&quot;fileTypes&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;js&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;jsx&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;mjs&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;cjs&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>

	<span class="token property">&quot;patterns&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
		<span class="token punctuation">{</span>
			<span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;string.quoted.double.js&quot;</span><span class="token punctuation">,</span>
			<span class="token property">&quot;match&quot;</span><span class="token operator">:</span> <span class="token string">&quot;\\\\\\&quot;(.*?)\\\\\\&quot;&quot;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>It\u2019ll feel overwhelming to consider <em>all</em> of the things a grammar does, so for this example I\u2019ve removed all of its rules except for one: the one that highlights double-quoted strings <code>&quot;like this&quot;</code>. You can see that it looks for a particular pattern and, when it matches, assigns the name <code>string.quoted.double.js</code> to that range. That\u2019s called a <strong>scope name</strong>.</p><p>When you load a JavaScript file in Pulsar \u2014 or VSCode, or Sublime Text \u2014 this grammar will find all your strings and mark them with scope names. In turn, your editor\u2019s syntax theme will hook into that scope name to make that string a special color. (It will most likely target <code>string</code>, rather than something more specific, but that\u2019s why scope names are divided into segments; targeting <code>string</code> will also match <code>string.quoted.double.js</code>.)</p><p>Let\u2019s make our grammar a bit more complex:</p><div class="language-json ext-json line-numbers-mode"><pre class="language-json"><code><span class="token punctuation">{</span>
	<span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;JavaScript&quot;</span><span class="token punctuation">,</span>
	<span class="token property">&quot;scopeName&quot;</span><span class="token operator">:</span> <span class="token string">&quot;source.js&quot;</span><span class="token punctuation">,</span>
	<span class="token property">&quot;fileTypes&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;js&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;jsx&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;mjs&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;cjs&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>

	<span class="token property">&quot;patterns&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
		<span class="token punctuation">{</span>
			<span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;string.quoted.double.js&quot;</span><span class="token punctuation">,</span>
			<span class="token property">&quot;begin&quot;</span><span class="token operator">:</span> <span class="token string">&quot;\\&quot;&quot;</span><span class="token punctuation">,</span>
			<span class="token property">&quot;beginCaptures&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
				<span class="token property">&quot;0&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;punctuation.definition.string.begin.js&quot;</span> <span class="token punctuation">}</span>
			<span class="token punctuation">}</span><span class="token punctuation">,</span>
			<span class="token property">&quot;end&quot;</span><span class="token operator">:</span> <span class="token string">&quot;\\&quot;&quot;</span><span class="token punctuation">,</span>
			<span class="token property">&quot;endCaptures&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
				<span class="token property">&quot;0&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;punctuation.definition.string.end.js&quot;</span> <span class="token punctuation">}</span>
			<span class="token punctuation">}</span><span class="token punctuation">,</span>
			<span class="token property">&quot;patterns&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
				<span class="token punctuation">{</span>
					<span class="token property">&quot;include&quot;</span><span class="token operator">:</span> <span class="token string">&quot;#string_escapes&quot;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">]</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This is practically the exact rule for double-quoted strings from Pulsar\u2019s built-in TextMate grammar for JavaScript. It introduces some more advanced concepts:</p><ul><li>Instead of a single pattern, we\u2019ve now got <code>begin</code> and <code>end</code> patterns. If it can identify a buffer range that starts with a <code>begin</code> match and ends with an <code>end</code> match, it can scope the entire range that way, and can create a new context in which only certain patterns are applied \u2014 in this case, escape sequences.</li><li>The entire string will still be scoped <code>string.quoted.double.js</code>, but now we\u2019re also applying <code>punctuation</code> scope names to the quote characters themselves.</li></ul><p>Here\u2019s a better way to visualize this:</p><p><img src="`+r+'" alt="string scopes"></p><p>If you were to put your cursor anywhere within a buffer and run the <strong>Editor: Log Cursor Scope</strong> command, you\u2019d see a list of scope names that are active at that buffer position, moving from broadest to narrowest:</p><p><img src="'+h+'" alt="log cursor scopes"></p>',12),A={href:"https://macromates.com/manual/en/language_grammars#naming_conventions",target:"_blank",rel:"noopener noreferrer"},H=a('<p>Still, you\u2019d be forgiven if you felt like this was overkill. All we\u2019re doing here is applying some syntax highlighting, right? Do you need this much information just to make a string green?</p><h2 id="how-textmate-uses-scope-names" tabindex="-1"><a class="header-anchor" href="#how-textmate-uses-scope-names" aria-hidden="true">#</a> How TextMate uses scope names</h2><p>TextMate has a good reason for wanting such verbose scope names, and for sprinkling them so liberally throughout your source code: they aren\u2019t used <em>just</em> for syntax highlighting.</p><p>It\u2019s better to think of scope names as intelligent annotations for your source code. The idea isn\u2019t that you\u2019ll want to make single-quoted strings a different color from double-quoted strings \u2014 though you could! \u2014\xA0but rather that other editor features could benefit from knowing <em>whether</em> you were inside a string, and <em>what kind</em> of string you were inside.</p><p>Because in TextMate, most editor actions \u2014 commands, snippets, and macros \u2014 can be made contextually aware.</p><p>Let\u2019s use commands as an example. Here are some commands you can write in TextMate:</p><ul><li>If the cursor is within a string, pressing <kbd>Ctrl-Shift-\u2019</kbd> should convert the string between single-quoted and double-quoted delimiters.</li><li>If the cursor is in the middle of <code>{}</code>, pressing <kbd>Return</kbd> should insert two newlines, put the cursor between the two newlines, and indent the cursor\u2019s line by one level.</li><li>If the cursor is within a URL, pressing <kbd>Enter</kbd> on the number pad should open that URL in a web browser.</li></ul><p>In fact, all of these are real examples that are enabled by default in TextMate. And because they target generic scope names that are shared across a number of grammars, they\u2019ll work in nearly any language.</p><p>Did you notice how our grammar file defined a <code>scopeName</code> of <code>source.js</code>? That\u2019s a <em>root</em> scope name, and it applies to the entire file. And it means that commands can restrict themselves to certain languages just like any other context.</p>',9),L=e("code",null,"prettier",-1),C={href:"https://www.html-tidy.org/",target:"_blank",rel:"noopener noreferrer"},B=e("code",null,"jq",-1),N=a('<p>In TextMate, file beautification commands canonically use the hotkey <kbd>Ctrl-Shift-H</kbd>. By applying the right scope selector for each of these three commands, you can assign them <em>all</em> to <kbd>Ctrl-Shift-H</kbd>, and they won\u2019t get in each other\u2019s way.</p><h2 id="how-pulsar-uses-scope-names" tabindex="-1"><a class="header-anchor" href="#how-pulsar-uses-scope-names" aria-hidden="true">#</a> How Pulsar uses scope names</h2><p>There are a number of reasons why TextMate isn\u2019t widely used anymore: it\u2019s a macOS-only editor, its releases are frustratingly sporadic, and it\u2019s never had support for crucial features like split editor panes. But TextMate was a major influence on how Atom was built.</p><p>It\u2019s not widely known, but <strong>Atom and Pulsar offer nearly as much flexibility with scope names as TextMate does</strong>:</p><ul><li><p>Any snippet can be defined to run in an arbitrary scope context. For instance, you could write a snippet that will only expand if you\u2019re inside of a JavaScript block comment; if you try to invoke it elsewhere, it\u2019ll act as though that snippet doesn\u2019t exist.</p><p>Built-in packages use this system. For instance, the <code>language-html</code> package defines snippets for most common tag names, but then redefines each one to do nothing if the cursor is inside a context where HTML would be invalid, like a <code>style</code> or <code>script</code> element.</p></li><li><p>Pulsar\u2019s configuration system allows for scope-specific overrides. For instance, a user can set <code>editor.softWrap</code> to <code>false</code> globally, but set it to <code>true</code> for Markdown files.</p><p>Built-in packages use this system. Scopes can be used to set config values that aren\u2019t exposed in the UI \u2014 like what to use for comment delimiters in a given language, or which non-letter characters should be considered to be part of a \u201Cword\u201D for the purposes of cursor navigation.</p></li><li><p>In Pulsar, commands can be invoked anywhere, whether the user is in a text editor or not; hence there\u2019s no strong system for enforcing that commands be invoked only in certain scope contexts.</p><p>But it\u2019s possible! I\u2019ve got several commands in my <code>init.js</code> whose only purpose is to inspect the scope list of the active text editor\u2019s cursor, then delegate to one of several other commands depending on where the cursor is. It\u2019s not as easy as it could be, but the bones are there.</p></li></ul><p>But that\u2019s not all. If you use Pulsar, chances are very good that you use a package \u2014\xA0built-in or third-party \u2014 that inspects scope names for contextual information. Here are just a few of <em>many</em> examples:</p>',6),P=e("li",null,[e("code",null,"autocomplete-plus"),t(" inspects scopes to decide whether it should offer suggestions at the cursor; it declines to do so whenever any of the current scopes matches a user-configurable list. (This is how it decides "),e("em",null,"not"),t(" to offer suggestions if you\u2019re typing within a comment, for instance.)")],-1),J=e("li",null,[e("code",null,"autocomplete-css"),t(" decides which suggestions to offer based on the scope name of the closest token.")],-1),W=e("li",null,[e("code",null,"bracket-matcher"),t(" uses scope names to locate and highlight paired tokens like brackets and matching HTML tags.")],-1),F={href:"https://web.pulsar-edit.dev/packages/emmet",target:"_blank",rel:"noopener noreferrer"},V=e("code",null,"emmet",-1),R=e("h2",{id:"what-would-break",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#what-would-break","aria-hidden":"true"},"#"),t(" What would break?")],-1),z={href:"https://github.com/tree-sitter/tree-sitter-javascript/blob/master/queries/highlights.scm#L85-L88",target:"_blank",rel:"noopener noreferrer"},E=e("code",null,"tree-sitter-javascript/queries/highlights.scm",-1),U=a(`<div class="language-scm ext-scm line-numbers-mode"><pre class="language-scm"><code>[
  (string)
  (template_string)
] @string
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This rule treats three different kinds of strings \u2014\xA0single-quoted, double-quoted, and backtick-quoted \u2014 identically. If we used this rule as written, we\u2019d be applying a scope name of <code>string</code> to all JavaScript strings. Not <code>string.quoted.double.js</code> and the like; just <code>string</code>. And there\u2019s no rule in that file that applies scope names to string delimiters, either.</p><p>If we embraced a system that used names like <code>string</code> and <code>comment</code> instead of <code>string.quoted.double.js</code> and <code>comment.block.documentation.js</code>, the editing experience would be worse in a number of ways ways \u2014 some tiny, some large.</p><p>To drive it home for you, let\u2019s think of all the things that would break from this change alone:</p><ul><li>Any community syntax theme that chose to style double-quoted strings differently from single quoted strings would suddenly behave differently. (Far-fetched? Consider a language like PHP or Ruby in which single-quoted strings have different semantics from double-quoted strings.)</li><li>Any community syntax theme that chose to style string delimiters in a certain way \u2014\xA0with a bolder weight, perhaps \u2014 would suddenly behave differently, because the <code>punctuation</code> scopes would no longer be present on the delimiters.</li><li>Any user-defined snippet that is scoped specifically to <code>string.quoted.double</code> \u2014 or even <code>string.quoted</code> \u2014 would break.</li><li>Any user-defined commands that looked for the presence of a <code>punctuation</code> scope to detect whether the cursor is adjacent to a string delimiter would break.</li></ul><p>I think Atom learned this lesson rather well during the original rollout of Tree-sitter grammars. After updating, users were defaulted to the new grammars. Sometimes things looked different, or behaved differently. When users reported these differences, they learned that they could work around those bugs in the short term by unchecking the \u201CUse Tree-Sitter Grammars\u201D setting and restoring the original behavior. I wonder how many did, and how many of them ever re-enabled Tree-sitter grammars in the future.</p><p>A lot of code has been written that presumes the existence of TextMate-style scopes. I think this is fine. The fact that we have a new system doesn\u2019t mean that we should leave scopes behind. For one thing, it\u2019d be a jarring experience for users \u2014\xA0we\u2019d be bragging about a new feature that was likely to break customizations that users had been relying upon for years.</p>`,7),G={href:"https://en.wikipedia.org/wiki/Middleware",target:"_blank",rel:"noopener noreferrer"},D=a('<h2 id="the-challenge" tabindex="-1"><a class="header-anchor" href="#the-challenge" aria-hidden="true">#</a> The challenge</h2><p>So that\u2019s why I volunteered to do this. I knew that we couldn\u2019t just reuse some syntax highlighting query files that were written with different assumptions in place. And I knew that I couldn\u2019t reasonably ask <em>someone else</em> to do a bunch of work just because <em>I</em> felt like it was important.</p><p>My goal was to create a set of grammars that had the performance and accuracy upsides of the Tree-sitter experience <em>and</em> the rich scope name annotations that TextMate grammars provided.</p><p>For that to be possible, Tree-sitter grammars should apply scope names <strong>as similarly as possible to TextMate grammars</strong>. There may be reasons that we <em>choose</em> not to do something the way that the TextMate grammar does it, but we don\u2019t want to be <em>unable</em> to do something the way that the TextMate grammar does it.</p><p>Syntax highlighting was the first, and hardest, task. Next time I\u2019ll talk about how we solved it.</p>',5);function O(Y,K){const i=o("RouterLink"),n=o("ExternalLinkIcon");return c(),p("div",null,[e("p",null,[t("In "),s(i,{to:"/blog/20230925-savetheclocktower-modern-tree-sitter-part-1.html"},{default:u(()=>[t("the last post")]),_:1}),t(", I tried to explain why the new Tree-sitter integration was worth writing about in the first place: because we needed to integrate it into a system defined by TextMate grammars, and we had to solve some challenging problems along the way.")]),g,d(" more "),e("p",null,[t("When I first started getting involved with Pulsar back in January, "),e("a",f,[t("@mauricioszabo"),s(n)]),t(" had just begun the process of migrating us to the "),b,t(" bindings, and seemed to be dreading the enormity of the task.")]),e("p",null,[t("He noticed that most Tree-sitter parsers had "),e("a",k,[t("their own built-in query files"),s(n)]),t(" for syntax highlighting. These "),y,t(" files act like a sort of stylesheet for a Tree-sitter tree: they\u2019re used when you run "),e("a",w,[v,s(n)]),t(" from the command line, and they\u2019re what GitHub uses when it highlights code in a web browser.")]),q,_,x,e("p",null,[t("You may not have ever used "),e("a",T,[t("TextMate"),s(n)]),t(", but you\u2019ve probably used an editor that benefited from its existence. Several widely used editors \u2014 first "),e("a",j,[t("Sublime Text"),s(n)]),t(", then Atom, and now "),e("a",I,[t("Visual Studio Code"),s(n)]),t(" \u2014 all based their grammar systems on TextMate\u2019s.")]),e("p",null,[t("A "),e("a",M,[t("TextMate grammar"),s(n)]),t(" doesn\u2019t aim to understand your code entirely. It uses regular expressions \u2014 pattern-matching \u2014\xA0to describe rules that identify the important parts of your code. It knows that some rules apply broadly and others are valid only in certain contexts, so it allows you to nest rules inside other rules.")]),S,e("p",null,[t("Why is it choosing those specific names? Because of "),e("a",A,[t("naming conventions established by TextMate"),s(n)]),t(" many years ago. When different language grammars try to abide by the same conventions for naming their scopes, it makes it easier to write syntax themes without constantly checking how they look in every possible language.")]),H,e("p",null,[t("For instance: to beautify your JavaScript, you might want to run it through "),L,t(". To beautify your HTML, you might want to run it through "),e("a",C,[t("HTML Tidy"),s(n)]),t(". And to beautify your JSON, you might want to run it through "),B,t(".")]),N,e("ul",null,[P,J,W,e("li",null,[e("a",F,[V,s(n)]),t(", the eighth-most-downloaded community package, relies on scope descriptors to decide whether it should try to expand an abbreviation into HTML.")])]),R,e("p",null,[t("With this in mind, let\u2019s go back to those built-in Tree-sitter query files and consider our string example. In "),e("a",z,[E,s(n)]),t(" we can see how strings are treated:")]),U,e("p",null,[t("But I also think that TextMate-style scopes function as an elegant "),e("a",G,[t("middleware"),s(n)]),t(". They allow us to change an underlying implementation without the user needing to know or care \u2014 except, perhaps, to notice downstream benefits, like faster syntax highlighting and new editor features.")]),D])}const Z=l(m,[["render",O],["__file","20230927-savetheclocktower-modern-tree-sitter-part-2.html.vue"]]);export{Z as default};
