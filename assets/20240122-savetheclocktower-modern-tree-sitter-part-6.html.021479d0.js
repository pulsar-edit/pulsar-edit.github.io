import{_ as l,o as c,c as d,e as h,a as t,b as e,d as o,w as i,f as a,r as n}from"./app.87197fef.js";const u="/assets/symbols-view-demo.17f7e949.webm",p="/assets/symbols-view-demo.946869fd.mp4",m="/assets/service-diagram-1.38837fcc.png",g="/assets/service-diagram-2.0af85dad.png",b="/assets/service-diagram-3.c330b93e.png",f="/assets/project-symbols.f73386c6.png",y="/assets/go-to-declaration-example.87adc60b.webm",w="/assets/go-to-declaration-example.62447add.mp4",v="/assets/symbol-provider-bookmarks-example.96a7a05d.png",k="/assets/symbols-view-tree-sitter-demo.16754842.webm",_="/assets/symbols-view-tree-sitter-demo.21174d35.mp4",x="/assets/symbols-view-json.951c60f0.png",T={},I=t("p",null,[e("We\u2019ve been telling a series of stories about all the different ways that Tree-sitter can improve the editing experience in Pulsar. Today\u2019s story about "),t("code",null,"symbols-view"),e(" starts a bit slowly, but it\u2019s got a great ending:\xA0the addition of a major new feature to Pulsar 1.113.")],-1),j=t("h2",{id:"background",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#background","aria-hidden":"true"},"#"),e(" Background")],-1),S={href:"https://github.com/mauricioszabo/",target:"_blank",rel:"noopener noreferrer"},A=t("blockquote",null,[t("p",null,[e("Currently, \u201Cdefinitions\u201D are implemented using CTags in "),t("code",null,"symbols-view"),e(". What do you think about transforming this into a \u201Cservice\u201D, like "),t("code",null,"pulsar.definitions"),e(" or "),t("code",null,"editor.definitions"),e("? That way, the tokenizer can \u201Cpush\u201D definitions into this service, and "),t("code",null,"symbols-view"),e(" can query for the definitions on the current file.")])],-1),D=t("p",null,"I\u2019ll explain what he\u2019s talking about.",-1),C={href:"https://github.com/pulsar-edit/symbols-view/blob/master/README.md",target:"_blank",rel:"noopener noreferrer"},P=t("code",null,"symbols-view",-1),B=t("code",null,"render",-1),E=a('<ul><li>press <kbd>Ctrl+R</kbd> (or <kbd>Cmd+R</kbd> on macOS),</li><li>start typing <code>render</code>, and</li><li>press <kbd>Return</kbd> to accept the first result in the list (or use arrow keys or the mouse to navigate to a different result).</li></ul><p>Choosing the <code>render</code> symbol in your symbols list will move the editor to the line where <code>render</code> is defined.</p><video style="max-width:100%;" autoplay controls muted loop><source src="'+u+'" type="video/webm"><source src="'+p+'" type="video/mp4"><p>Your browser doesn\u2019t support HTML video. <a href="@source/blog/assets/symbols-view-demo.mp4">Download this video</a> instead.</p></video>',3),R=t("code",null,"render",-1),L=t("code",null,"ctags",-1),q={href:"https://ctags.sourceforge.net/",target:"_blank",rel:"noopener noreferrer"},F=t("p",null,[e("(What Maur\xEDcio calls \u201Cdefinitions\u201D is what "),t("code",null,"symbols-view"),e(" calls \u201Csymbols,\u201D and what "),t("code",null,"ctags"),e(" calls, well, \u201Ctags.\u201D For simplicity I\u2019ll use the term \u201Csymbol\u201D just to align with what Pulsar calls it.)")],-1),H=t("code",null,"ctags",-1),M=t("em",null,"plenty",-1),O=t("em",null,"at all",-1),W={href:"https://github.com/pulsar-edit/symbols-view/blob/master/lib/ctags-config",target:"_blank",rel:"noopener noreferrer"},Y=t("code",null,"symbols-view",-1),N=t("code",null,"ctags",-1),G=t("em",null,"great",-1),J={href:"https://tree-sitter.github.io/tree-sitter/code-navigation-systems",target:"_blank",rel:"noopener noreferrer"},U=t("code",null,"ctags",-1),V=a('<p>You might have noticed how GitHub can nowadays give you an outline-like view of a source code file, listing lines where methods are defined. That\u2019s all happening through Tree-sitter. If GitHub can use it for symbol navigation, so can we.</p><h2 id="refactoring-symbols-view" tabindex="-1"><a class="header-anchor" href="#refactoring-symbols-view" aria-hidden="true">#</a> Refactoring <code>symbols-view</code></h2><p>But to make that happen, we need to change how <code>symbols-view</code> works. All it knows about is <code>ctags</code>! Could we rip all that out and replace it with a Tree-sitter solution? Yes, but in the process we\u2019d be abandoning support for any languages that don\u2019t yet have Tree-sitter parsers.</p><p>A better approach would be to know about <em>both</em> strategies and pick the best one on the fly. So let\u2019s figure out exactly what Maur\xEDcio\u2019s request \u2014 \u201Ctransforming [symbols] into a \u2018service\u2019\u201D \u2014 means.</p><h3 id="a-crash-course-in-services" tabindex="-1"><a class="header-anchor" href="#a-crash-course-in-services" aria-hidden="true">#</a> A crash course in services</h3><p>In Pulsar, <strong>services</strong> are how packages talk to one another. Suppose I\u2019ve authored <code>package-b</code> and it depends on another package called <code>package-a</code> that someone else has written. I could reach into <code>atom.packages</code> and grab the reference to <code>package-a</code>, but this feels weird for a number of reasons. For one, it incorrectly assumes that <code>package-a</code> has already been activated. It may get activated <em>after</em> <code>package-b</code> \u2014 or else it may <em>never</em> get activated because the user has disabled or uninstalled it.</p><p>But even if <code>package-b</code> were able to find and consume package <code>package-a</code> this way, it\u2019d create a tight coupling between the two. That coupling would break if <code>package-a</code> renamed itself, or if it changed implementation details that <code>package-b</code> was relying on.</p><p>So instead of communicating directly, they can invent a service called <code>foo</code> and use it to communicate. One package defines itself as a <em>provider</em> of service <code>foo</code>, and the other defines itself as a <em>consumer</em> of service <code>foo</code>.</p><p>During startup, Pulsar will activate each package, notice the match, and arrange an introduction as soon as <em>both packages</em> have been activated. The provider will end up returning an object that the consumer can use however it likes; this object is typically some sort of interface with methods that the consumer can call.</p><p>Services thus act as <em>contracts</em> between packages. And they can be versioned, too. If it wants, <code>package-a</code> can provide several different versions of the service at once; this leaves the author free to make changes without breaking packages that consume the older version.</p><h3 id="a-built-in-example" tabindex="-1"><a class="header-anchor" href="#a-built-in-example" aria-hidden="true">#</a> A built-in example</h3><p>This flexibility makes new things possible. Consider a package like <code>autocomplete-plus</code>, the bundled package that provides an autocompletion menu in Pulsar. It doesn\u2019t try to implement the various tactics that can be used to suggest completion candidates; all it does is make the user interface for an autocomplete menu. It then defines an <strong><code>autocomplete.provider</code></strong> service so that <em>other</em> packages can provide completion suggestions. Packages like <code>autocomplete-html</code>, <code>autocomplete-css</code>, and others know how to suggest context-specific completions at the cursor, so they feed that data to <code>autocomplete-plus</code>.</p><p><img src="'+m+'" alt="Service Diagram 1"></p><p>We like this approach because it gives users an incredible amount of control. For example, if you don\u2019t like the HTML autocompletion suggestions, you can change <code>autocomplete-html</code>\u2019s configuration, or even disable it entirely. Or you could write your own alternative to <code>autocomplete-html</code>. Or you could even write your own alternative to <code>autocomplete-plus</code>! By registering as a <em>consumer</em> of <code>autocomplete.provider</code>, your replacement package would be able to communicate with packages like <code>autocomplete-html</code> just as easily as <code>autocomplete-plus</code> can.</p><p><img src="'+g+'" alt="Service Diagram 2"></p><p>This is the model we need for <code>symbols-view</code>. We now have a second approach for generating symbols that can compete favorably with the <code>ctags</code> strategy. So let\u2019s reinvent <code>symbols-view</code> in the style of <code>autocomplete-plus</code> and make it a consumer of a new service we\u2019ll invent named <strong><code>symbol.provider</code></strong>.</p><p><img src="'+b+'" alt="Service Diagram 3"></p><p>The built-in <code>ctags</code> provider can be spun off into a package called <code>symbol-provider-ctags</code>, and our new Tree-sitter\u2013based approach can be in a package called <code>symbol-provider-tree-sitter</code>. These packages can provide the <code>symbol.provider</code> service for <code>symbols-view</code> to consume.</p><h3 id="how-will-it-work" tabindex="-1"><a class="header-anchor" href="#how-will-it-work" aria-hidden="true">#</a> How will it work?</h3>',19),z=t("code",null,"highlights.scm",-1),X=t("code",null,"tags.scm",-1),K=a('<p>When a user presses <kbd>Ctrl+R</kbd> / <kbd>Cmd+R</kbd>, we can run a query against the current buffer. Any node that is captured as <code>@name</code> in a <code>tags.scm</code> file can be represented as a symbol. Often the node will be contained in a larger capture called (for example) <code>@definition.function</code>; we can detect that and infer that the text captured by <code>@name</code> refers to a function.</p><p>The information we get is not only <em>richer</em> than what <code>ctags</code> can provide, but also <em>more accurate</em>, since we\u2019re querying against the current buffer text. Even if the file hasn\u2019t been saved recently. Even if it hasn\u2019t been saved at all!</p><p>Now, we can only do this when the file in question is using a Tree-sitter grammar, so it\u2019s not a universal solution. But we can prefer a Tree-sitter symbol provider where it\u2019s available, and fall back to our <code>ctags</code> provider where it isn\u2019t.</p><h3 id="project-symbols" tabindex="-1"><a class="header-anchor" href="#project-symbols" aria-hidden="true">#</a> Project symbols</h3><p>Another thing that <code>symbols-view</code> has long supported \u2014 theoretically \u2014 is <em>project</em>-based symbol navigation, allowing you to search for and jump to symbols in other files.</p><p><img src="'+f+'" alt="Project Symbols example"></p><p>It\u2019s been able to do this because <code>ctags</code> can read project-wide symbol metadata \u2014 a genuine upside it has over some other approaches. But this feature only works if the user has generated a special file called a \u201Ctags file\u201D for their project. Pulsar itself can\u2019t generate this file on its own because it doesn\u2019t know which files it should crawl to find symbols (imagine if it tried to crawl your entire <code>node_modules</code> folder!), so the <code>ctags</code> strategy requires the user to regenerate that file on a regular basis.</p><p>For now, our Tree-sitter symbol provider can only suggest symbols in the current file. If you activate <strong>Toggle Project Symbols</strong> via <kbd>Ctrl+Shift+R</kbd> / <kbd>Cmd+Shift+R</kbd>, it won\u2019t even volunteer for the job. Using Tree-sitter to list the symbols in an open buffer is very fast precisely because the buffer is <em>open</em>; we\u2019ve already paid the startup cost of the initial parse. But there\u2019s no way Tree-sitter could parse all of a project\u2019s files in a similar amount of time. If we want project-wide symbol search we\u2019ll have to look elsewhere.</p><h3 id="go-to-declaration" tabindex="-1"><a class="header-anchor" href="#go-to-declaration" aria-hidden="true">#</a> Go to declaration</h3><p>\u201CWho cares,\u201D you may think. And I\u2019ll admit I don\u2019t attempt a project-wide symbol search very often. But there\u2019s a related feature I\u2019m pretty sure you\u2019ll like.</p><p><code>symbols-view</code> defines a <strong>Go To Declaration</strong> command. It\u2019ll search the project for a symbol matching the word under the cursor. If there\u2019s one result, it\u2019ll get opened automatically; if there\u2019s more than one, it offers up the options in a list for you to choose. And when you\u2019re done, there\u2019s a corresponding <strong>Return From Declaration</strong> command that takes you back to the place you just were.</p><p>Dive into a definition with <kbd>Ctrl+Alt+Down</kbd> / <kbd>Cmd+Alt+Down</kbd>, then return to the surface with <kbd>Ctrl+Alt+Up</kbd> / <kbd>Cmd+Alt+Up</kbd>:</p><video style="max-width:100%;" autoplay controls muted loop><source src="'+y+'" type="video/webm"><source src="'+w+'" type="video/mp4"><p>Your browser doesn\u2019t support HTML video. <a href="@source/blog/assets/go-to-declaration-example.mp4">Download this video</a> instead.</p></video><p>Here I\u2019ve demonstrated it on a TypeScript type, but it\u2019ll work on functions and classes and other types of things, too.</p><p>Did you know this feature existed? I didn\u2019t. It\u2019s been available to you this whole time <em>if</em> you\u2019ve had a tags file to supply project-wide symbols, the way <em>nobody</em> does. But with a refactored <code>symbols-view</code>, another candidate for supplying these symbols enters the arena: a <em>language server</em>.</p><h3 id="language-servers" tabindex="-1"><a class="header-anchor" href="#language-servers" aria-hidden="true">#</a> Language servers</h3>',16),Q={href:"https://en.wikipedia.org/wiki/Language_Server_Protocol",target:"_blank",rel:"noopener noreferrer"},Z=t("p",null,[e("There are a handful of Pulsar packages named like "),t("code",null,"ide-x"),e(", where "),t("code",null,"x"),e(" is the name of a language. Several of them were even originally developed by the Atom team. For now I\u2019ll call them "),t("strong",null,"IDE backend packages"),e(".")],-1),$=t("p",null,[e("What these packages have in common is that they all run something called a "),t("em",null,"language server"),e(" under the hood. A language server is designed to be a brain for a few dozen common features you\u2019d want from your code editor: autocompletion, code linting, refactor support, and the like. A single language server typically knows how to do these tasks for one specific language or framework.")],-1),ee={href:"https://www.npmjs.com/package/typescript-language-server",target:"_blank",rel:"noopener noreferrer"},te=t("code",null,"symbols-view",-1),oe={href:"https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_documentSymbol",target:"_blank",rel:"noopener noreferrer"},se=t("code",null,"textDocument/documentSymbol",-1),ae={href:"https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workspace_symbol",target:"_blank",rel:"noopener noreferrer"},re=t("code",null,"workspace/symbol",-1),ie={href:"https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_definition",target:"_blank",rel:"noopener noreferrer"},ne=t("code",null,"textDocument/definition",-1),le=t("p",null,[e("But here\u2019s the bad news: since the "),t("code",null,"symbol.provider"),e(" service has only just been invented, those IDE backend packages need updates before they can be used for symbol navigation.")],-1),ce=t("code",null,"ide-typescript",-1),de={href:"https://web.pulsar-edit.dev/packages/pulsar-ide-typescript-alpha",target:"_blank",rel:"noopener noreferrer"},he=t("code",null,"pulsar-ide-typescript-alpha",-1),ue=t("code",null,"ide-typescript",-1),pe=a('<p>And it might take a few version bumps on dependencies, but most other IDE backend packages can also be updated to take advantage of these features.</p><h3 id="anyway-back-to-symbols-view" tabindex="-1"><a class="header-anchor" href="#anyway-back-to-symbols-view" aria-hidden="true">#</a> Anyway, back to <code>symbols-view</code></h3><p>Unlike <code>autocomplete-plus</code>, which aggregates suggestions from multiple providers and shows all of them to the user, <code>symbols-view</code> is mainly interested in choosing <em>the</em> best provider for the job. There\u2019s little point in aggregating across a language server <em>and</em> Tree-sitter <em>and</em> <code>ctags</code>, since they\u2019re largely going to be offering the same list of symbols with varying degrees of richness, and you\u2019d be pretty annoyed if Pulsar offered you three different list entries for the same function. Inside <code>symbols-view</code> they\u2019re called \u201Cexclusive\u201D providers because only one of them will be picked for the job.</p><p>But I wanted to leave the door open for some creative and unexpected usages, so <code>symbols-view</code> also has a concept of \u201Csupplemental\u201D providers. A provider that marks itself as supplemental is saying it\u2019d like to contribute symbols that would probably not already be in an exclusive provider\u2019s list. You may be wondering what kinds of symbols would fit the bill, so let me give you an example\u2026</p><p>Did you know you can bookmark lines in a buffer? Try it out: right-click on any line of your editor and select <strong>Toggle Bookmark</strong>. The built-in <code>bookmarks</code> package keeps track of them and will also let you navigate between them via <kbd>F2</kbd> and <kbd>Shift+F2</kbd>.</p>',5),me={href:"https://web.pulsar-edit.dev/packages/symbol-provider-bookmarks",target:"_blank",rel:"noopener noreferrer"},ge=t("code",null,"symbol-provider-bookmarks",-1),be=t("code",null,"symbols-view",-1),fe=t("p",null,[t("img",{src:v,alt:"symbol-provider-bookmarks example"})],-1),ye={href:"https://web.pulsar-edit.dev/packages/symbol-provider-bookmarks",target:"_blank",rel:"noopener noreferrer"},we=a('<h2 id="shipping-now" tabindex="-1"><a class="header-anchor" href="#shipping-now" aria-hidden="true">#</a> Shipping now</h2><p>I\u2019ve had most of this article written for months, but I decided to wait to publish it until we could show this stuff off. That time is now.</p><p>Pulsar 1.113 makes two major changes that will vastly improve the quality of the symbol searching you might already be accustomed to:</p><ol><li><p>The new version of <code>symbols-view</code> is now in place. It will offer you <code>ctags</code>-based symbols in grammars that don\u2019t use Tree-sitter, but it will prefer Tree-sitter\u2013supplied symbols in most grammars. If you truly don\u2019t like change, you can disable the <code>symbol-provider-tree-sitter</code> package and just rely on <code>symbol-provider-ctags</code>, or else you can configure <code>symbols-view</code> to prefer some providers over others.</p><p>But I\u2019m betting you\u2019ll want to keep using the symbols provided by Tree-sitter, because\u2026</p></li><li><p>As you may have heard, modern Tree-sitter grammars are now the default! The system that we shipped in experimental fashion back in Pulsar 1.106 is now ready for prime time. For now, you can opt back into legacy Tree-sitter with the new <code>core.useLegacyTreeSitter</code> setting \u2014 but not for long, because the legacy system will be dropped when we\u2019re finally able to migrate to a newer version of Electron.</p></li></ol>',4),ve=t("kbd",null,"Ctrl+R",-1),ke=t("kbd",null,"Cmd+R",-1),_e=t("em",null,"across the board",-1),xe={href:"https://github.com/pulsar-edit/pulsar/issues",target:"_blank",rel:"noopener noreferrer"},Te=a('<p>How does this actually improve the <code>symbols-view</code> experience? Let\u2019s see what our original example looks like with a Tree-sitter symbol provider:</p><video style="max-width:100%;" autoplay controls muted loop><source src="'+k+'" type="video/webm"><source src="'+_+'" type="video/mp4"><p>Your browser doesn\u2019t support HTML video. <a href="@source/blog/assets/symbols-view-tree-sitter-demo.mp4">Download this video</a> instead.</p></video><p>The richness of the metadata we get from these sources has allowed us to enhance the <code>symbols-view</code> UI, too! You\u2019ll be shown the \u201Ckind\u201D of thing that a symbol is \u2014\xA0class, function, constant, et cetera. In many cases, these kinds will be illustrated with icons. Visit the package settings page for <code>symbols-view</code> to explore the possibilities.</p><p>And there are even a few <em>killer</em> new features. Open a symbols list on a JSON file and marvel at the entries you see:</p><p><img src="'+x+'" alt="symbols-view JSON example"></p>',5),Ie=t("em",null,"entire key path",-1),je={href:"https://github.com/pulsar-edit/pulsar/blob/master/packages/symbol-provider-tree-sitter/README.md#advanced-features",target:"_blank",rel:"noopener noreferrer"},Se=t("code",null,"symbol-provider-tree-sitter",-1),Ae={href:"https://web.pulsar-edit.dev/packages/pulsar-ide-typescript-alpha",target:"_blank",rel:"noopener noreferrer"},De=t("code",null,"pulsar-ide-typescript-alpha",-1),Ce=t("em",null,"and",-1),Pe=t("code",null,"ide-x",-1),Be={href:"https://github.com/orgs/pulsar-edit/discussions",target:"_blank",rel:"noopener noreferrer"},Ee={href:"https://discord.gg/7aEbB9dGRT",target:"_blank",rel:"noopener noreferrer"},Re={href:"https://pulsar-edit.dev/community.html",target:"_blank",rel:"noopener noreferrer"},Le=t("h2",{id:"conclusion",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#conclusion","aria-hidden":"true"},"#"),e(" Conclusion")],-1),qe=t("em",null,"yet another",-1),Fe=t("em",null,"even better",-1),He=t("p",null,"Integrating Tree-sitter has been a difficult project. I started working on it in earnest in February of 2023; it shipped in June behind an experimental flag; and it\u2019s finally the default grammar type in January of 2024.",-1),Me=t("p",null,"Our Tree-sitter series is nearing an end, but there\u2019s one more thing to cover: the challenges. Could it have been easier? Can Tree-sitter overcome its pain points and drawbacks? We\u2019ll talk about it next time.",-1);function Oe(We,Ye){const s=n("ExternalLinkIcon"),r=n("RouterLink");return c(),d("div",null,[I,h(" more "),j,t("p",null,[e("Back in March, "),t("a",S,[e("@mauricioszabo"),o(s)]),e(" gave me an assignment:")]),A,D,t("p",null,[e("You might already use the "),t("a",C,[P,e(" package"),o(s)]),e(" to navigate to important parts of your source code files. For instance, if you want to jump to the definition of "),B,e(" in a given file, you can")]),E,t("p",null,[e("This is a time-saving feature. But how does it work? How does Pulsar know which items to put in the list? How does it know where your "),R,e(" method is defined? You might be surprised: it uses an ancient program called "),L,e(" \u2014 specifically a fork called "),t("a",q,[e("Exuberant Ctags"),o(s)]),e(".")]),F,t("p",null,[H,e(" works well enough that you might never notice its drawbacks, but it\u2019s got "),M,e(" of drawbacks. It reads files from disk, so it can return inaccurate results if you use it on a file that has been modified since its last save. For the same reason, it doesn\u2019t work "),O,e(" on new files that haven\u2019t yet been saved. And it needs "),t("a",W,[e("special configuration"),o(s)]),e(" for each language it supports \u2014 meaning that, even after you\u2019ve written a Pulsar grammar for your newly-invented Language X, you won\u2019t get any symbol-based navigation unless you modify the "),Y,e(" package itself and tell "),N,e(" how to find your language\u2019s symbols.")]),t("p",null,[e("I know you\u2019re probably tired of hearing me say \u201CTree-sitter would be "),G,e(" for this task!\u201D \u2014 but "),t("a",J,[e("code navigation systems"),o(s)]),e(" really are in its wheelhouse. The trees we\u2019re already using to highlight code and do other useful tasks can be queried to supply symbols much more easily than via "),U,e(". And many parsers even come bundled with a query file that does the work of identifying the symbols we\u2019re interested in.")]),V,t("p",null,[e("I\u2019ve "),o(r,{to:"/blog/20230927-savetheclocktower-modern-tree-sitter-part-2.html"},{default:i(()=>[e("talked about why")]),_:1}),e(" Pulsar chose not to leverage the built-in "),z,e(" query files that exist for most Tree-sitter parsers: we needed richer information than they could provide. Luckily, that\u2019s not true for other kinds of files! Many parsers also provide "),X,e(" query files, and they\u2019re easy for us to consume as-is.")]),K,t("p",null,[e("I hesitate to mention "),t("a",Q,[e("language servers"),o(s)]),e(" merely in passing, because they\u2019re a deep enough topic to require their own multi-part blog post series. But let me give it a shot.")]),Z,$,t("p",null,[e("Language servers are exciting because they make it easier for weirdos like us to use editors other than the market leader. Instead of having to write all those features from scratch for, say, TypeScript, an upstart code editor could instead communicate with "),t("a",ee,[e("typescript-language-server"),o(s)]),e(" and write some glue code to wire up the language server\u2019s features to the features of the editor.")]),t("p",null,[e("The good news is that the language server specification includes several actions that are relevant to "),te,e(": "),t("a",oe,[se,o(s)]),e(" for same-file symbols, "),t("a",ae,[re,o(s)]),e(" for project-wide symbols, and even "),t("a",ie,[ne,o(s)]),e(" for finding where a symbol is defined. Some IDE backend packages already have \u201Cbrains\u201D capable of doing these tasks!")]),le,t("p",null,[e("I\u2019ve started to do a bit of that work. Inspired by "),ce,e(" \u2014\xA0but mainly starting fresh \u2014\xA0I\u2019ve been working on a package currently called "),t("a",de,[he,o(s)]),e(" that aims to be its drop-in replacement. It should be able to do everything that "),ue,e(" can already do, but it will also be able to offer project-wide symbol search and go-to-declaration functionality.")]),pe,t("p",null,[e("Anyway, to illustrate the idea of a supplemental provider, I wrote one: "),t("a",me,[ge,o(s)]),e(" will turn each of your bookmarks into a symbol, then display them in the "),be,e(" UI alongside your main provider\u2019s symbols, using the text of the bookmarked line as the symbol name.")]),fe,t("p",null,[e("This one\u2019s not bundled with Pulsar, so "),t("a",ye,[e("grab it from the package registry"),o(s)]),e(" if it sounds interesting.")]),we,t("p",null,[e("Because common languages like JavaScript, Python, Ruby, and many others have full-featured modern Tree-sitter grammars, they will also be using our new Tree-sitter symbol provider for "),ve,e(" / "),ke,e(". That means the symbol results should be better "),_e,e(" \u2014 more accurate and more comprehensive. (If it seems worse, please "),t("a",xe,[e("file a bug"),o(s)]),e(".)")]),Te,t("p",null,[e("The "),Ie,e(" is now the name of the symbol! The same sorts of query and predicate tricks we\u2019ve seen in previous installments in this series can be used for awesome features like this. "),t("a",je,[e("The "),Se,e(" README"),o(s)]),e(" has more details.")]),t("p",null,[e("And it\u2019s early days for "),t("a",Ae,[De,o(s)]),e(", but I\u2019ve been using it for a few months as a symbol provider (and a go-to-declaration provider!) on TypeScript "),Ce,e(" JavaScript projects. Feel free to give it a shot yourself. (And if you\u2019re interested in bringing one of the other "),Pe,e(" packages into the year 2024, please do broach the topic on "),t("a",Be,[e("GitHub Discussions"),o(s)]),e(", "),t("a",Ee,[e("Discord"),o(s)]),e(", or "),t("a",Re,[e("one of our other communities"),o(s)]),e(".)")]),Le,t("p",null,[e("After overhauling Pulsar\u2019s "),o(r,{to:"/blog/20231013-savetheclocktower-modern-tree-sitter-part-3.html"},{default:i(()=>[e("syntax highlighting")]),_:1}),e(", "),o(r,{to:"/blog/20231031-savetheclocktower-modern-tree-sitter-part-4.html"},{default:i(()=>[e("indentation, code folding")]),_:1}),e(", and "),o(r,{to:"/blog/20231110-savetheclocktower-modern-tree-sitter-part-5.html"},{default:i(()=>[e("language injections")]),_:1}),e(", we\u2019ve found "),qe,e(" way that Tree-sitter can improve our existing editor experience. But in this case, there\u2019s an "),Fe,e(" improvement just around the corner: IDE backend packages and language servers. I\u2019ll be sure to go into more detail on the Pulsar IDE experience in future posts.")]),He,Me])}const Ge=l(T,[["render",Oe],["__file","20240122-savetheclocktower-modern-tree-sitter-part-6.html.vue"]]);export{Ge as default};
