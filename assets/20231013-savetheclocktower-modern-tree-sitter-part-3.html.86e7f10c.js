import{_ as o}from"./tree-sitter-string-scopes-diagram.2db37c5c.js";import{_ as i,o as r,c as d,a as t,b as e,d as n,e as c,f as a,r as l}from"./app.87197fef.js";const p="/assets/tree-sitter-tools-string-tree.3fe45d43.png",u="/assets/tree-sitter-comment-scopes-diagram.88665730.png",h="/assets/tree-sitter-tools-comment-tree.f78df2f6.png",m="/assets/tree-sitter-snippet-context-example.f7c0921c.webm",g="/assets/tree-sitter-snippet-context-example.8124fdcd.mp4",v={},f={href:"https://pulsar-edit.dev/blog/20230927-savetheclocktower-modern-tree-sitter-part-2.html",target:"_blank",rel:"noopener noreferrer"},b=t("strong",null,[e("make it so that a Tree-sitter grammar can do "),t("em",null,"anything"),e(" a TextMate grammar can do.")],-1),w=t("p",null,"Today I\u2019d like to show you the specific problems that we had to solve in order to pull that off.",-1),y={href:"https://web.pulsar-edit.dev/packages/tree-sitter-tools",target:"_blank",rel:"noopener noreferrer"},k=t("code",null,"tree-sitter-tools",-1),_={href:"https://tree-sitter.github.io/tree-sitter/playground",target:"_blank",rel:"noopener noreferrer"},j=a('<h2 id="the-problems" tabindex="-1"><a class="header-anchor" href="#the-problems" aria-hidden="true">#</a> The problems</h2><p>The legacy Tree-sitter integration into Atom used its own system for mapping tree nodes to scope names, but it had <strong>two major limitations</strong> that prevented it from matching the scope names produced by a TextMate grammar:</p><ol><li><strong>It couldn\u2019t query the right nodes</strong>: it used a CSS-like syntax that was limited in how expressively it could describe tree nodes.</li><li><strong>It couldn\u2019t describe the right ranges</strong>: it could only add scopes to ranges that corresponded to individual tree nodes.</li></ol><p>The need to write an Atom-specific bridge between node names and scope names served as evidence that Tree-sitter need its <em>own</em> system for more easily working with syntax trees \u2014 one that would prevent every Tree-sitter consumer from having to reinvent the wheel.</p>',4),x={href:"https://tree-sitter.github.io/tree-sitter/using-parsers#pattern-matching-with-queries",target:"_blank",rel:"noopener noreferrer"},q={href:"https://en.wikipedia.org/wiki/Scheme_(programming_language)",target:"_blank",rel:"noopener noreferrer"},T={href:"https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector",target:"_blank",rel:"noopener noreferrer"},S=t("code",null,"document.querySelector",-1),I=a('<p>Right now, though, let\u2019s just focus on syntax highlighting. And remember those two limitations that I described above, because we\u2019ll have to solve them both before this article is done.</p><h2 id="the-first-challenge-robust-querying" tabindex="-1"><a class="header-anchor" href="#the-first-challenge-robust-querying" aria-hidden="true">#</a> The first challenge: robust querying</h2><p>I\u2019ll remind you of our example from part 2: the scope names applied to a double-quoted string in JavaScript.</p><p><img src="'+o+'" alt="string scopes"></p><p>Our first goal is to make it so that our JavaScript Tree-sitter grammar can apply these same scopes to the same buffer ranges. But Tree-sitter works very differently to a TextMate grammar, so it\u2019s not immediately obvious how we can pull this off. Let\u2019s reason through it.</p><h3 id="how-captures-work" tabindex="-1"><a class="header-anchor" href="#how-captures-work" aria-hidden="true">#</a> How captures work</h3>',6),A={href:"https://tree-sitter.github.io/tree-sitter/syntax-highlighting",target:"_blank",rel:"noopener noreferrer"},W=t("code",null,"highlights.scm",-1),P=t("code",null,"tree-sitter highlight",-1),M=t("code",null,"highlights.scm",-1),L=a(`<p>Last time I showed you this excerpt from <code>tree-sitter-javascript</code>\u2019s <code>highlights.scm</code> file:</p><div class="language-scm ext-scm line-numbers-mode"><pre class="language-scm"><code>[
  (string)
  (template_string)
] @string
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Once you\u2019re familiar with query syntax, the outcome of this query is clear: all JavaScript strings will be captured and given a name of <code>@string</code>. Somewhere within the <code>tree-sitter highlight</code> code path, those capture names are mapped to various colors, and are applied to the captured buffer ranges. Anything that gets captured as <code>@string</code> will have one color in the output; anything that gets captured as <code>@keyword</code> will have a different color; and so on.</p><p><strong>Let\u2019s imagine that Pulsar has a similar system.</strong> In order to keep this article from putting you to sleep, I won\u2019t get into the details of exactly <em>how</em> we do it, but the machinery is in place. Instead of a capture name like <code>@string</code>, we\u2019ll be choosing more verbose names like <code>@string.quoted.double.js</code>, but the principles are the same.</p><p>We also won\u2019t be talking about how Pulsar knows which areas of the buffer to re-highlight as the user makes changes, nor how Pulsar combines the results of multiple parsers (for example, JavaScript embedded in HTML). These topics may be visited in future articles, but today we\u2019re just talking about how to use Tree-sitter queries to identify arbitrary ranges and give them the scope names that we want.</p><h3 id="highlights" tabindex="-1"><a class="header-anchor" href="#highlights" aria-hidden="true">#</a> Highlights</h3><p>What does a string look like in a Tree-sitter tree? Let\u2019s create a new document with nothing but the following contents:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token string">&quot;like this&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,8),C={href:"https://web.pulsar-edit.dev/packages/tree-sitter-tools",target:"_blank",rel:"noopener noreferrer"},B=t("p",null,[t("img",{src:p,alt:"string tree"})],-1),N=t("p",null,[e("So we can see that a "),t("code",null,"string"),e(" node consists of three parts: a delimiter, a "),t("code",null,"string_content"),e(" node, and another delimiter. This structure maps elegantly to the things that we want to scope.")],-1),H={href:"https://en.wikipedia.org/wiki/Abstract_syntax_tree",target:"_blank",rel:"noopener noreferrer"},J=t("em",null,"abstract",-1),O=t("em",null,"concrete",-1),F=a(`<p>In Tree-sitter parsers, nodes that matter to semantics (like <code>string_content</code>) tend to have names, whereas other nodes (like the delimiters) are \u201Canonymous\u201D nodes. Anonymous nodes can still be queried against like named nodes, so it feels like it\u2019ll be pretty easy to apply the scopes that we want.</p><p>So let\u2019s open our grammar\u2019s <code>highlights.scm</code> file and give it a try. (In Pulsar\u2019s \u201Cdev mode\u201D \u2014 which you can trigger with the <code>--dev</code> flag on the command line \u2014 grammar authors can even make changes to their query files and see them take effect instantly when they save!)</p><div class="language-scm ext-scm line-numbers-mode"><pre class="language-scm"><code>(string) @string.quoted.double.js
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>That\u2019s not bad, but it\u2019s too specific. In <code>tree-sitter-javascript</code>, the <code>string</code> node applies for both single-quoted and double-quoted strings, with the difference being reflected only in the anonymous nodes. (Template strings, as we saw above, have their own node type.)</p><p>How do we distinguish single-quoted strings from double-quoted strings? Here\u2019s one thing we could do:</p><div class="language-scm ext-scm line-numbers-mode"><pre class="language-scm"><code>((string) @string.quoted.single.js
  (#match? @string.quoted.single.js &quot;^&#39;&quot;))
((string) @string.quoted.double.js
  (#match? @string.quoted.single.js &quot;^\\&quot;&quot;))
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The built-in <code>#match?</code> predicate allows us to reject possible matches when their contents don\u2019t match a given regular expression. Here we\u2019re telling the query engine to distinguish between <code>string</code> nodes whose text starts with <code>&#39;</code> and those whose text starts with <code>&quot;</code>.</p><p>We\u2019ll be using the <code>#match?</code> predicate a lot. Unlike some of the other predicates we\u2019ll see shortly, it\u2019s <em>implemented</em> by the <code>web-tree-sitter</code> bindings, so Tree-sitter on its own is able to reject would-be captures that don\u2019t pass it. By the time we see the list of captures, those that have failed a <code>#match?</code> test have already been filtered out.</p><p>In this case, though, there\u2019s an even easier way to tell these strings apart:</p><div class="language-scm ext-scm line-numbers-mode"><pre class="language-scm"><code>(string &quot;&#39;&quot;) @string.quoted.single.js
(string &quot;\\&quot;&quot;) @string.quoted.double.js
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>As I mentioned, we can query for the presence of anonymous nodes. So the first line will match any <code>string</code> that contains at least one anonymous node child named <code>&#39;</code>, and the second line will match any <code>string</code> that contains at least one anonymous node child named <code>&quot;</code>.</p><p>Since the capture name is on the outside of the closing parenthesis, the capture name applies to the whole <code>string</code>.</p><p>We don\u2019t have to be more specific; if that anonymous node exists <em>at all</em>, then it\u2019s used as a delimiter on both sides of the string. And this query won\u2019t match any potential false positives \u2014 like a double-quoted string that happens to have a <code>&#39;</code> somewhere inside of it \u2014 because the parser is too smart to get tripped up by that sort of thing.</p><p>This is one reason why it\u2019s very easy to make a new Tree-sitter grammar <em>if</em> someone has done the work of writing a Tree-sitter parser for the given language. If we were writing a TextMate grammar, we\u2019d have to care about a lot more of these edge cases, but a Tree-sitter parser will have handled them for us already.</p><h3 id="scope-tests" tabindex="-1"><a class="header-anchor" href="#scope-tests" aria-hidden="true">#</a> Scope tests</h3><p>We can already tell that the expressiveness of Tree-sitter\u2019s query system will go a long way toward solving the first of the two problems we described above. Last time around, Atom developers had to <em>invent</em> a system for querying the tree, but we get a much more powerful system for free.</p><p>Tools like anonymous nodes and <code>#match?</code> predicates can get us quite far on their own, but they can\u2019t solve all of our problems. We still have to scope the quotation marks themselves, and we may <em>think</em> we know how to do it:</p><div class="language-scm ext-scm line-numbers-mode"><pre class="language-scm"><code>(string &quot;&#39;&quot; @punctuation.definition.string.begin.js)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>By putting the capture name immediately after the <code>&quot;&#39;&quot;</code>, we can target that anonymous node and give it a name. But remember that there are two delimiters! We want to give one scope name to the beginning delimiter and a <em>different</em> scope name to the ending delimiter. As we\u2019ve written it, this rule would match <em>both</em> delimiters.</p>`,19),$={href:"https://tree-sitter.github.io/tree-sitter/using-parsers#anchors",target:"_blank",rel:"noopener noreferrer"},E=t("em",null,"named",-1),Y=t("strong",null,"We need a way to introduce our own filtering criteria into Tree-sitter queries.",-1),R=a(`<p>Luckily, Tree-sitter gives us the tools to write our own predicates. Instead of trying to make it aware of our application-specific concerns, we can use the generic predicates <code>#is?</code> and <code>#is-not?</code> to mark certain query captures with data, then use that data to filter the results however we like.</p><p>The downside is that Tree-sitter can\u2019t approve or reject captures with these predicates <em>on its own</em> like it can with <code>#match?</code>. Instead, we\u2019ll have to \u201Cprocess\u201D these captures after the fact and filter them manually. But it\u2019s worth the effort because\xA0it lets us use whatever logic we want \u2014\xA0even Pulsar-specific logic that means nothing to Tree-sitter.</p><p>Let\u2019s illustrate.</p><div class="language-scm ext-scm line-numbers-mode"><pre class="language-scm"><code>(string
  &quot;&#39;&quot; @punctuation.definition.string.begin.js
  (#is? test.first &quot;true&quot;))
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>The two parameters after <code>#is?</code> are arbitrary values of my own invention. Tree-sitter simply treats them as a key and value and applies some metadata to this capture. Any nodes that get captured by this query will contain some data under <code>assertedProperties</code>:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>capture<span class="token punctuation">.</span>assertedProperties<span class="token punctuation">[</span><span class="token string">&quot;test.first&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//-&gt; &quot;true&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>In fact, I can omit that second argument; for boolean tests like this one, the presence of the property is all we need:</p><div class="language-scm ext-scm line-numbers-mode"><pre class="language-scm"><code>(string
  &quot;&#39;&quot; @punctuation.definition.string.begin.js
  (#is? test.first))
(string
  &quot;&#39;&quot; @punctuation.definition.string.end.js
  (#is? test.last))
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Using <code>(#is? test.first)</code> is like having Tree-sitter attach a Post-It note to a capture object with the text \u201Cremember to assert <code>test.first</code> later\u201D written on it. Tree-sitter doesn\u2019t know or care what that means, but it assumes we will.</p><p>And in this case, <code>test.first</code> corresponds to a function we\u2019ve written that looks like this:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">first</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">.</span>parent<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> node<span class="token operator">?.</span>parent<span class="token operator">?.</span>firstChild<span class="token operator">?.</span>id <span class="token operator">===</span> node<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This function first ensures that root nodes (which have no parent) will always pass the test. Then it compares our node to its parent\u2019s first child. If they\u2019re equal, the test passes. If they\u2019re not, then the captured node isn\u2019t the first child of its parent, and we can ignore it.</p><p>The logic for our <code>last</code> function is identical, except that it compares our <code>node</code> to <code>node.parent.lastChild</code>.</p><p>Even better: the existence of <code>#is-not?</code> means that we get negation practically for free. Suppose I did this:</p><div class="language-scm ext-scm line-numbers-mode"><pre class="language-scm"><code>(string
  &quot;&#39;&quot; @punctuation.definition.string.end.js
  (#is-not? test.first))
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Then the metadata would exist in a different place\u2026</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token string">&quot;test.first&quot;</span> <span class="token keyword">in</span> capture<span class="token punctuation">.</span>refutedProperties<span class="token punctuation">;</span> <span class="token comment">//-&gt; true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>\u2026and I\u2019d know to ignore this capture unless my <code>first</code> function <em>fails</em> for this node.</p><p>So now we\u2019ve got a way to filter capture names by any criteria we can think of. If we can test for it in JavaScript, it can be used as a predicate in Tree-sitter queries.</p><p>We call these custom predicates <strong>scope tests</strong>, and we\u2019ve grouped them under a <code>test.</code> namespace for reasons that may make more sense later. Scope tests are a crucial tool for solving the first of those two problems we described earlier: they let us query for tree nodes in arbitrary ways that the legacy system simply couldn\u2019t.</p><p>And because scope tests are just JavaScript, we\u2019re able to use some oddball criteria for accepting or rejecting captures. Consider these examples:</p><div class="language-scm ext-scm line-numbers-mode"><pre class="language-scm"><code>((program) @source.js.embedded
  (#is? test.injection))

(variable_declarator
  name: (identifier) @constant.other.foo
  (#match? @constant.other.foo &quot;^[_A-Z]+$&quot;)
  (#is? test.config &quot;language-foo.highlightAllCapsIdentifiersAsConstants&quot;))
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Both of these are scope tests that grammar query files can use. The first one applies a scope <em>only</em> if we\u2019re in an injection layer \u2014 for instance, if this is JavaScript inside of a <code>SCRIPT</code> tag in an HTML file. The second one applies a scope only if the user has enabled a certain configuration option. Neither one has anything to do with Tree-sitter itself, but we can use them in Tree-sitter query files all the same.</p>`,23),U=t("code",null,"ScopeResolver",-1),V=t("code",null,"first",-1),z={href:"https://github.com/pulsar-edit/pulsar/blob/v1.109.0/src/scope-resolver.js#L583-L591",target:"_blank",rel:"noopener noreferrer"},D=t("code",null,"ScopeResolver.TESTS.first",-1),X=t("code",null,"ScopeResolver",-1),Z=t("code",null,"test.first",-1),G=a(`<p>There are other scope tests that we\u2019ve found to be quite useful \u2014\xA0tests which any grammar author can use in their own query files:</p><ul><li>Whether a node has a certain kind of node as an ancestor</li><li>Whether a node has a certain kind of node as a descendant</li><li>Whether a node is the first/last non-whitespace content on a row</li><li>Whether a node has arbitrary metadata that has been attached with Tree-sitter\u2019s <code>#set!</code> predicate</li></ul><p>But for our current goal \u2014 applying <code>punctuation</code> scopes to string delimiters \u2014 implementing <code>test.first</code> and <code>test.last</code> is enough to get us the outcome we want.</p><p>You may remember from earlier that the legacy Tree-sitter integration used a CSS-like syntax to describe nodes. It supported combinators like <code>&gt;</code> and even pseudoclasses like <code>:nth-child</code>, but not much else. Tree-sitter\u2019s own query system can do much more than that \u2014 and it\u2019s extensible, so we can add our own logic wherever we need it.</p><p>So we\u2019ve done it! We now have the ability to scope a JavaScript string identically between our two different grammar systems. And we\u2019ve moved past the legacy system\u2019s first drawback: a brittle query system. Our first challenge has been vanquished.</p><h2 id="the-second-challenge-scoping-arbitrary-ranges" tabindex="-1"><a class="header-anchor" href="#the-second-challenge-scoping-arbitrary-ranges" aria-hidden="true">#</a> The second challenge: scoping arbitrary ranges</h2><p>To solve the second drawback \u2014\xA0inability to scope the correct ranges \u2014 let\u2019s create another challenge.</p><p>TextMate grammars will scope comments differently based on whether they\u2019re line comments or block comments. There\u2019s also a convention to annotate <code>comment.line</code> scopes with their delimiter type:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// this is a comment</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>A typical TextMate grammar for JavaScript would scope this comment as <code>comment.line.double-slash.js</code>, and would further scope the <code>//</code> as <code>punctuation.definition.comment.js</code>.</p><p><img src="`+u+'" alt="comment scopes"></p><p>Can we do that in a Tree-sitter grammar with the tools we\u2019ve already got? Let\u2019s inspect what our example comment looks like in a Tree-sitter tree:</p><p><img src="'+h+`" alt="comment tree"></p><p>Hmm. No anonymous nodes or anything. Just one node called <code>comment</code>.</p><p>It\u2019s a strong Tree-sitter convention that various sorts of code comments are all represented by nodes called <code>comment</code>. So this query would do the right thing in our example\u2026</p><div class="language-scm ext-scm line-numbers-mode"><pre class="language-scm"><code>(comment) @comment.line.double-slash.js
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>\u2026but would be incorrect in other scenarios because it would match block comments as well as line comments.</p><p>But we can use <code>#match?</code> to distinguish between the two kinds of comments:</p><div class="language-scm ext-scm line-numbers-mode"><pre class="language-scm"><code>((comment) @comment.line.double-slash.js
  (#match? @comment.line.double-slash.js &quot;^\\/\\/&quot;))

((comment) @comment.block.js
  (#match? @comment.block.js &quot;^\\/*&quot;))
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>In the latter case, we don\u2019t have to test for the presence of <code>*/</code> at the end. If the contents of the comment begin with <code>/*</code>, that\u2019s all the information we need; we know it <em>must</em> end with <code>*/</code>, or else the parser wouldn\u2019t have classified it as a comment.</p><p>But what about our <code>punctuation.definition.comment.js</code> scope? Sadly, <code>tree-sitter-javascript</code> (and most other parsers) don\u2019t make it easy to target the comment delimiters themselves. Comment delimiters, unlike string delimiters, usually aren\u2019t available as anonymous nodes.</p><p>Hence the legacy Tree-sitter system has never been able to annotate that <code>//</code> with the <code>punctuation</code> scope it needed. We\u2019ll need to solve this ourselves.</p><h3 id="scope-adjustments" tabindex="-1"><a class="header-anchor" href="#scope-adjustments" aria-hidden="true">#</a> Scope adjustments</h3><p>In this case, it\u2019d be <em>more convenient</em> if there were a node for the <code>//</code> we want to scope. But we control the internals of the editor, and we can tell it to apply scope names to whatever buffer ranges we want. When the tree doesn\u2019t do all of our work for us, it just means we have to try a bit harder.</p><p>In this case, the <code>comment</code> node tells us where the comment <em>starts</em> in the buffer. And once it passes the <code>#match?</code> predicate, we <em>know</em> that it starts with <code>//</code>, so it <em>must</em> end two characters later. Not the hardest problem to solve!</p><p>The trickiest part will be figuring out <em>how to describe</em> these buffer positions in a query.</p><h4 id="adjusting-by-pattern" tabindex="-1"><a class="header-anchor" href="#adjusting-by-pattern" aria-hidden="true">#</a> Adjusting by pattern</h4><p>What if we did this?</p><div class="language-scm ext-scm line-numbers-mode"><pre class="language-scm"><code>((comment) @comment.line.double-slash.js
  (#match? @comment.line.double-slash.js &quot;^//&quot;))

((comment) @punctuation.definition.comment.js
  (#match? @punctuation.definition.comment.js &quot;^//&quot;)
  (#set! adjust.endAfterFirstMatchOf &quot;^//&quot;))
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Here we\u2019re capturing the same thing <em>twice</em> under different names. In the second case, we\u2019re using <code>#set!</code> \u2014\xA0a predicate very similar to <code>#is?</code> and <code>#is-not?</code> \u2014 to attach a qualifier: instead of stopping at the end of the line comment, stop\xA0right after the <code>//</code> near the beginning.</p><p>Just like <code>#is?</code> predicates are represented on captures under <code>assertedProperties</code> and <code>#is-not?</code> predicates are represented under <code>refutedProperties</code>, <code>#set!</code> predicates are represented in their own bucket simply called <code>properties</code>.</p><p>Note the semantic difference between a predicate that ends in <code>!</code> and one that ends in <code>?</code>. In this case we\u2019re not setting up a test for the capture to pass or fail; we\u2019re attaching a side effect to the capture. Imagine a Post-It note attached to the capture that says \u201Cremember to adjust the range for this capture to end at X.\u201D</p><p>I mentioned earlier that all nodes remember their corresponding buffer range \u2014 starting at <em>row W and column X</em>, ending at <em>row Y and column Z</em>. By default, this is the range against which a scope is applied. But in this case, the <code>adjust.endAfterFirstMatchOf</code> predicate reminds us to execute a regular expression match on the node\u2019s contents and move the ending position to <em>the end of that match</em>, instead of the node\u2019s natural ending point.</p>`,33),K={href:"https://github.com/pulsar-edit/pulsar/blob/v1.109.0/src/scope-resolver.js#L883-L897",target:"_blank",rel:"noopener noreferrer"},Q=a(`<p>And how would we handle the delimiters of a block comment?</p><div class="language-scm ext-scm line-numbers-mode"><pre class="language-scm"><code>((comment) @comment.block.js
	(#match? @comment.block.js &quot;^/\\\\*&quot;))

((comment) @punctuation.definition.comment.begin.js
  (#match? @punctuation.definition.comment.begin.js &quot;^/\\\\*&quot;)
  (#set! adjust.endAfterFirstMatchOf &quot;^/\\\\*&quot;))

((comment) @punctuation.definition.comment.end.js
  (#match? @punctuation.definition.comment.end.js &quot;\\\\*/$&quot;)
  (#set! adjust.startBeforeFirstMatchOf &quot;\\\\*/$&quot;))

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>We can scope the opening delimiter the same way. To scope the ending delimiter, we move the <em>head</em> of the range to the position at the <em>beginning</em> of a regex match. (And for situations where you want to move both the head and the tail at once, there\u2019s <code>adjust.startAndEndAroundFirstMatchOf</code>).</p><h4 id="adjusting-by-node-position-descriptor" tabindex="-1"><a class="header-anchor" href="#adjusting-by-node-position-descriptor" aria-hidden="true">#</a> Adjusting by node position descriptor</h4><p>Let\u2019s look at another example.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">SomeComponent</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token operator">&lt;</span>SomeOtherComponent <span class="token punctuation">{</span><span class="token operator">...</span>props<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Let\u2019s say we want to scope the <code>/&gt;</code> at the end of the self-closing tag. Tree-sitter represents that as two separate anonymous nodes \u2014 <code>/</code> and <code>&gt;</code>.</p><p>So we\u2019ve got a <em>different</em> problem here: there\u2019s no <em>single</em> node that includes both boundaries of the range we want to scope. How can we make the scope span two adjacent nodes?</p><p>We could probably use a pattern-based solution here like we did above. But we could also leverage a useful feature of how nodes are represented in the tree.</p>`,9),ee={href:"https://developer.mozilla.org/en-US/docs/Web/API/Node",target:"_blank",rel:"noopener noreferrer"},te=t("code",null,"parentNode",-1),se=t("code",null,"nextSibling",-1),ne=a(`<p>A similar system exists for Tree-sitter nodes, and it gives us a simple way to describe relationships between nodes:</p><div class="language-scm ext-scm line-numbers-mode"><pre class="language-scm"><code>((jsx_self_closing_element
  ; The &quot;/&gt;&quot; in \`&lt;Foo /&gt;\`, extended to cover both anonymous nodes at once.
  &quot;/&quot;) @punctuation.definition.tag.end.js
  (#set! adjust.startAt lastChild.previousSibling.startPosition)
  (#set! adjust.endAt lastChild.endPosition))
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Here we\u2019re capturing the entire self-closing element, then moving the ends of the range to the specific boundaries that we need: starting at the beginning of second-to-last node child, and ending at the end of the last node child. The <code>/</code> and <code>&gt;</code> will always be the last two children of the node we captured, so this is a simple and repeatable way to describe the boundaries we want.</p>`,3),ae=t("em",null,"node position descriptor",-1),oe={href:"https://docs-lodash.com/v4/get/",target:"_blank",rel:"noopener noreferrer"},ie=t("code",null,"_.get",-1),re=a(`<p>So in order to pass our \u201CJavaScript line comment\u201D challenge, we\u2019ve had to invent another feature called <strong>scope adjustments</strong>. With the infrastructure we\u2019ve already got, scope adjustments are an easy thing to add: a scope adjustment is just a function that accepts a capture object and returns a range. We process them in the post-capture phase immediately before we apply scope tests.</p><p>Scope adjustments are our answer to the legacy system\u2019s second limitation. They allow us to embrace the syntax tree when it works in our favor, but still break free of it whenever we need to.</p><h2 id="what-does-this-get-us" tabindex="-1"><a class="header-anchor" href="#what-does-this-get-us" aria-hidden="true">#</a> What does this get us?</h2><p>Some of you, having gotten this far, might wonder to yourselves: <em>if it takes this much effort just to get feature parity with a TextMate grammar, why not just stick with TextMate grammars?</em></p><p>One answer is simple: despite how complex this may seem, and how many implementation details I\u2019ve hidden from you, the effort it\u2019s taken to integrate Tree-sitter grammars into Pulsar is much, much less than the effort it originally took to integrate TextMate grammars into Atom.</p><p>But the message here can\u2019t just be \u201Cwe implemented a cool new thing that you won\u2019t notice at all!\u201D The whole point is that this is <em>better than</em> \u2014 not just <em>equivalent to</em> \u2014\xA0what we had before, and not just for the few of us who write grammars.</p><p>So let me give you an example of\xA0something that was very hard with a TextMate grammar, but is now quite easy.</p><p>When a scope name might be useful for semantic reasons, but not for syntax highlighting reasons, TextMate grammars add scope names that use the <code>meta</code> namespace. You might see some <code>meta</code> scope names when you run the \u201CLog Cursor Scope\u201D command, but most of them don\u2019t have an effect on how your code looks. Yet that information is visible to snippets, settings, and commands, and it can be very useful.</p><p>In the <code>language-javascript</code> package, Pulsar defines a <code>fun</code> snippet that expands as follows, with the string <code>functionName</code> highlighted:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">functionName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>That\u2019s great, but there\u2019s more than one syntax for defining functions. Imagine if you could use <code>fun</code> inside of a class body and have it expand to the correct syntax for defining an instance method:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
	<span class="token function">functionName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Or inside of an object literal \u2014 much like the class body syntax, but with a trailing comma so as to prevent syntax errors:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> Foo <span class="token operator">=</span> <span class="token punctuation">{</span>
	<span class="token function">functionName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>TextMate grammars weren\u2019t built with this sort of thing in mind.</strong> With much effort, you could probably pull it off, but only by making the grammar so complex that it might as well be a parser. But Tree-sitter is <em>already</em> a parser. It understands your code well enough to make these things <em>easy</em>.</p><p>With our rich syntax tree, we can now apply <code>meta</code> scope names rather liberally, marking sections of the buffer with useful metadata that can be used by commands and snippets. We can scope the inside of a class body and the inside of an object literal:</p><div class="language-scm ext-scm line-numbers-mode"><pre class="language-scm"><code>; The interior of a class body.
((class_body) @meta.block.class.js
  ; Start after \`{\`\u2026
  (#set! adjust.startAt firstChild.endPosition)
  ; \u2026and end before \`}\`.
  (#set! adjust.endAt lastChild.startPosition))

; The inside of an object literal.
((object) @meta.object.js
  ; Start after \`{\`\u2026
  (#set! adjust.startAt firstChild.endPosition)
  ; \u2026and end before \`}\`.
  (#set! adjust.endAt lastChild.startPosition))
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>By defining these two scope names, we\u2019ve exposed these concepts to all the systems that consume scope names, including snippets.</p><p>The <code>language-javascript</code> package already defines <code>fun</code> one way, but we can redefine it for more specific scopes:</p><div class="language-coffeescript ext-coffeescript line-numbers-mode"><pre class="language-coffeescript"><code><span class="token string-property property">&#39;.source.js .meta.block.class.js&#39;</span><span class="token operator">:</span>
  <span class="token string-property property">&#39;Function&#39;</span><span class="token operator">:</span>
    <span class="token string-property property">&#39;prefix&#39;</span><span class="token operator">:</span> <span class="token string">&#39;fun&#39;</span>
    <span class="token string-property property">&#39;body&#39;</span><span class="token operator">:</span> <span class="token string">&#39;\${1:functionName}($2) {\\n\\t$0\\n}&#39;</span>

<span class="token string-property property">&#39;.source.js .meta.object.js&#39;</span><span class="token operator">:</span>
  <span class="token string-property property">&#39;Function&#39;</span><span class="token operator">:</span>
    <span class="token string-property property">&#39;prefix&#39;</span><span class="token operator">:</span> <span class="token string">&#39;fun&#39;</span>
    <span class="token string-property property">&#39;body&#39;</span><span class="token operator">:</span> <span class="token string">&#39;\${1:functionName}($2) {\\n\\t$0\\n},&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Now we\u2019ve made the <code>fun</code> snippet much more useful. When we type <code>fun</code> and press <kbd>Tab</kbd>, the <code>snippets</code> package will pick the version that matches the context of the cursor most closely.</p><video style="max-width:100%;" autoplay controls muted><source src="`+m+'" type="video/webm"><source src="'+g+'" type="video/mp4"><p>Your browser doesn\u2019t support HTML video. <a href="@source/blog/assets/tree-sitter-snippet-context-example.mp4">Download this video</a> instead.</p></video><p>This will work identically whether you use tab triggers or choose your snippets from an autocomplete menu.</p><p>This change isn\u2019t just theoretical; it\u2019s been implemented in the <code>language-javascript</code> grammar package, and it shipped with Pulsar 1.109.</p><h2 id="next-time" tabindex="-1"><a class="header-anchor" href="#next-time" aria-hidden="true">#</a> Next time</h2><p>Syntax highlighting isn\u2019t the only way that Tree-sitter\u2019s query system can make our lives easier. In the next installment we\u2019ll tackle two tasks that the legacy Tree-sitter integration never addressed: indentation and code folding.</p>',26);function de(ce,le){const s=l("ExternalLinkIcon");return r(),d("div",null,[t("p",null,[t("a",f,[e("Last time I laid out the case"),n(s)]),e(" for why we chose to embrace TextMate-style scope names, even in newer Tree-sitter grammars. I set a difficult challenge for Pulsar: "),b]),w,c(" more "),t("p",null,[e("If you\u2019d like to follow along with these code examples in your own Pulsar installation, I\u2019d suggest installing the "),t("a",y,[k,e(" package"),n(s)]),e(". It includes a language grammar for the Tree-sitter query files we\u2019ll be spending most of this article writing, and it lets us visualize the syntax trees that Tree-sitter produces.")]),t("p",null,[e("If you just want to get a sense of what a Tree-sitter tree looks like, you can use the "),t("a",_,[e("Playground on the Tree-sitter web site"),n(s)]),e(".")]),j,t("p",null,[e("So Tree-sitter added a powerful "),t("a",x,[e("query system"),n(s)]),e(", with a Lisp-like syntax most directly influenced by "),t("a",q,[e("Scheme"),n(s)]),e(". This system wasn\u2019t around for the legacy implementation to use \u2014 but it\u2019s here for us now, and it\u2019s going to make our job much easier.")]),t("p",null,[e("Tree-sitter query syntax does the same thing for a Tree-sitter syntax tree that CSS selector syntax does for HTML: it gives us a terse way to describe a set of nodes in a tree. And just as people eventually realized that CSS selector syntax was useful for more than just styling \u2014 see "),t("a",T,[S,n(s)]),e(" \u2014 you\u2019ll soon see that Tree-sitter queries are useful for more than just making strings green.")]),I,t("p",null,[e("Tree-sitter itself "),t("a",A,[e("has demonstrated"),n(s)]),e(" how query files can be used to highlight code. If a parser has a "),W,e(" file defined in its repository, the CLI will allow you to run "),P,e(" on arbitrary input. It\u2019ll parse the input, figure out which parser should do the job, use that parser\u2019s "),M,e(" to map certain nodes to query capture names, and then emit highlighted output in your terminal.")]),L,t("p",null,[e("Using the "),t("a",C,[e("tree-sitter-tools package"),n(s)]),e(", I can open an inspector pane and look at the raw tree for this string:")]),B,N,t("p",null,[e("Most parsers build "),t("a",H,[J,e(" syntax trees"),n(s)]),e(". In the process of making the tree, they discard lots of information that isn\u2019t important to the parser\u2019s goal. But Tree-sitter builds "),O,e(" syntax trees! Every character in our JavaScript file will end up being represented by at least one node, and every node remembers the exact buffer range it covers. If it didn\u2019t, we wouldn\u2019t be able to use it for syntax highlighting.")]),F,t("p",null,[e("Surprisingly, we can\u2019t solve this problem without some external help. Tree-sitter queries "),t("a",$,[e("have a concept of \u201Canchors\u201D"),n(s)]),e(" that can enforce positioning of children \u2014 for instance, targeting only the first node child of a parent \u2014 but they can be used only for "),E,e(" nodes, not anonymous nodes. "),Y]),R,t("p",null,[e("The logic for applying tests and winnowing a list of raw captures exists in Pulsar in a class called "),U,e(". That "),V,e(" function defined above is present at "),t("a",z,[D,n(s)]),e(", and there\u2019s logic in "),X,e(" that matches up a "),Z,e(" property to that function.")]),G,t("p",null,[e("So in the absence of any node boundary at the position we want, we\u2019ve found a rather simple alternative way to express that position. We still have to write "),t("a",K,[e("our own code"),n(s)]),e(" to make it happen, but that won\u2019t be a problem. Since we already have to loop through our captures to apply scope tests, we might as well use that opportunity to tweak the range of a capture if we need to.")]),Q,t("p",null,[e("You might be familiar with how "),t("a",ee,[e("DOM nodes in the browser"),n(s)]),e(" are traversible via properties like "),te,e(", "),se,e(", and so on. If you\u2019ve got a reference to a particular DOM node, you can use those properties to jump from that node to any other node in the tree, as long as you you know how the two nodes are related.")]),ne,t("p",null,[e("This syntax for describing a position relative to a given node is something we call a "),ae,e(". If you\u2019ve ever used a function like "),t("a",oe,[e("Lodash\u2019s "),ie,n(s)]),e(", you might feel at home with this syntax \u2014 it resolves a chain of property lookups all at once, and fails gracefully if any of them aren\u2019t present. It\u2019ll come in handy later for other purposes.")]),re])}const he=i(v,[["render",de],["__file","20231013-savetheclocktower-modern-tree-sitter-part-3.html.vue"]]);export{he as default};
